/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.CurveAccountDTO
import org.openapitools.client.models.CurveAddLiquidityEventDTO
import org.openapitools.client.models.CurveAdminFeeChangeLogDTO
import org.openapitools.client.models.CurveAmplificationCoeffChangeLogDTO
import org.openapitools.client.models.CurveCoinDTO
import org.openapitools.client.models.CurveContractDTO
import org.openapitools.client.models.CurveContractVersionDTO
import org.openapitools.client.models.CurveDailyVolumeDTO
import org.openapitools.client.models.CurveExchangeDTO
import org.openapitools.client.models.CurveFeeChangeLogDTO
import org.openapitools.client.models.CurveGaugeDTO
import org.openapitools.client.models.CurveGaugeDepositDTO
import org.openapitools.client.models.CurveGaugeLiquidityDTO
import org.openapitools.client.models.CurveGaugeTotalWeightDTO
import org.openapitools.client.models.CurveGaugeTypeDTO
import org.openapitools.client.models.CurveGaugeTypeWeightDTO
import org.openapitools.client.models.CurveGaugeWeightDTO
import org.openapitools.client.models.CurveGaugeWeightVoteDTO
import org.openapitools.client.models.CurveGaugeWithdrawDTO
import org.openapitools.client.models.CurveHourlyVolumeDTO
import org.openapitools.client.models.CurveLpTokenDTO
import org.openapitools.client.models.CurvePoolDTO
import org.openapitools.client.models.CurveProposalDTO
import org.openapitools.client.models.CurveProposalVoteDTO
import org.openapitools.client.models.CurveRemoveLiquidityEventDTO
import org.openapitools.client.models.CurveRemoveLiquidityOneEventDTO
import org.openapitools.client.models.CurveSystemStateDTO
import org.openapitools.client.models.CurveTokenDTO
import org.openapitools.client.models.CurveTransferOwnershipEventDTO
import org.openapitools.client.models.CurveUnderlyingCoinDTO
import org.openapitools.client.models.CurveVotingAppDTO
import org.openapitools.client.models.CurveWeeklyVolumeDTO

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CurveApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://onchain.coinapi.io")
        }
    }

    /**
     * Accounts (current)
     * Gets accounts.
     * @return kotlin.collections.List<CurveAccountDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveAccountsCurrent() : kotlin.collections.List<CurveAccountDTO> {
        val localVarResponse = curveAccountsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveAccountDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Accounts (current)
     * Gets accounts.
     * @return ApiResponse<kotlin.collections.List<CurveAccountDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveAccountsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveAccountDTO>?> {
        val localVariableConfig = curveAccountsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveAccountDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveAccountsCurrent
     *
     * @return RequestConfig
     */
    fun curveAccountsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/accounts/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * AddLiquidityEvents (current)
     * Gets addLiquidityEvents.
     * @return kotlin.collections.List<CurveAddLiquidityEventDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveAddLiquidityEventsCurrent() : kotlin.collections.List<CurveAddLiquidityEventDTO> {
        val localVarResponse = curveAddLiquidityEventsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveAddLiquidityEventDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * AddLiquidityEvents (current)
     * Gets addLiquidityEvents.
     * @return ApiResponse<kotlin.collections.List<CurveAddLiquidityEventDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveAddLiquidityEventsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveAddLiquidityEventDTO>?> {
        val localVariableConfig = curveAddLiquidityEventsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveAddLiquidityEventDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveAddLiquidityEventsCurrent
     *
     * @return RequestConfig
     */
    fun curveAddLiquidityEventsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/addLiquidityEvents/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * AdminFeeChangeLogs (current)
     * Gets adminFeeChangeLogs.
     * @return kotlin.collections.List<CurveAdminFeeChangeLogDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveAdminFeeChangeLogsCurrent() : kotlin.collections.List<CurveAdminFeeChangeLogDTO> {
        val localVarResponse = curveAdminFeeChangeLogsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveAdminFeeChangeLogDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * AdminFeeChangeLogs (current)
     * Gets adminFeeChangeLogs.
     * @return ApiResponse<kotlin.collections.List<CurveAdminFeeChangeLogDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveAdminFeeChangeLogsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveAdminFeeChangeLogDTO>?> {
        val localVariableConfig = curveAdminFeeChangeLogsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveAdminFeeChangeLogDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveAdminFeeChangeLogsCurrent
     *
     * @return RequestConfig
     */
    fun curveAdminFeeChangeLogsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/adminFeeChangeLogs/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * AmplificationCoeffChangeLogs (current)
     * Gets amplificationCoeffChangeLogs.
     * @return kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveAmplificationCoeffChangeLogsCurrent() : kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO> {
        val localVarResponse = curveAmplificationCoeffChangeLogsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * AmplificationCoeffChangeLogs (current)
     * Gets amplificationCoeffChangeLogs.
     * @return ApiResponse<kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveAmplificationCoeffChangeLogsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO>?> {
        val localVariableConfig = curveAmplificationCoeffChangeLogsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveAmplificationCoeffChangeLogDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveAmplificationCoeffChangeLogsCurrent
     *
     * @return RequestConfig
     */
    fun curveAmplificationCoeffChangeLogsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/amplificationCoeffChangeLogs/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Coins (current)
     * Gets coins.
     * @return kotlin.collections.List<CurveCoinDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveCoinsCurrent() : kotlin.collections.List<CurveCoinDTO> {
        val localVarResponse = curveCoinsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveCoinDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Coins (current)
     * Gets coins.
     * @return ApiResponse<kotlin.collections.List<CurveCoinDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveCoinsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveCoinDTO>?> {
        val localVariableConfig = curveCoinsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveCoinDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveCoinsCurrent
     *
     * @return RequestConfig
     */
    fun curveCoinsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/coins/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * ContractVersions (current)
     * Gets contractVersions.
     * @return kotlin.collections.List<CurveContractVersionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveContractVersionsCurrent() : kotlin.collections.List<CurveContractVersionDTO> {
        val localVarResponse = curveContractVersionsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveContractVersionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * ContractVersions (current)
     * Gets contractVersions.
     * @return ApiResponse<kotlin.collections.List<CurveContractVersionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveContractVersionsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveContractVersionDTO>?> {
        val localVariableConfig = curveContractVersionsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveContractVersionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveContractVersionsCurrent
     *
     * @return RequestConfig
     */
    fun curveContractVersionsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/contractVersions/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Contracts (current)
     * Gets contracts.
     * @return kotlin.collections.List<CurveContractDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveContractsCurrent() : kotlin.collections.List<CurveContractDTO> {
        val localVarResponse = curveContractsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveContractDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Contracts (current)
     * Gets contracts.
     * @return ApiResponse<kotlin.collections.List<CurveContractDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveContractsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveContractDTO>?> {
        val localVariableConfig = curveContractsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveContractDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveContractsCurrent
     *
     * @return RequestConfig
     */
    fun curveContractsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/contracts/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DailyVolumes (current)
     * Gets dailyVolumes.
     * @return kotlin.collections.List<CurveDailyVolumeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveDailyVolumesCurrent() : kotlin.collections.List<CurveDailyVolumeDTO> {
        val localVarResponse = curveDailyVolumesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveDailyVolumeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DailyVolumes (current)
     * Gets dailyVolumes.
     * @return ApiResponse<kotlin.collections.List<CurveDailyVolumeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveDailyVolumesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveDailyVolumeDTO>?> {
        val localVariableConfig = curveDailyVolumesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveDailyVolumeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveDailyVolumesCurrent
     *
     * @return RequestConfig
     */
    fun curveDailyVolumesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/dailyVolumes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Exchanges (current)
     * Gets exchanges.
     * @param pool  (optional)
     * @return kotlin.collections.List<CurveExchangeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveExchangesCurrent(pool: kotlin.String? = null) : kotlin.collections.List<CurveExchangeDTO> {
        val localVarResponse = curveExchangesCurrentWithHttpInfo(pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveExchangeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Exchanges (current)
     * Gets exchanges.
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<CurveExchangeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveExchangesCurrentWithHttpInfo(pool: kotlin.String?) : ApiResponse<kotlin.collections.List<CurveExchangeDTO>?> {
        val localVariableConfig = curveExchangesCurrentRequestConfig(pool = pool)

        return request<Unit, kotlin.collections.List<CurveExchangeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveExchangesCurrent
     *
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun curveExchangesCurrentRequestConfig(pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/exchanges/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * FeeChangeLogs (current)
     * Gets feeChangeLogs.
     * @return kotlin.collections.List<CurveFeeChangeLogDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveFeeChangeLogsCurrent() : kotlin.collections.List<CurveFeeChangeLogDTO> {
        val localVarResponse = curveFeeChangeLogsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveFeeChangeLogDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * FeeChangeLogs (current)
     * Gets feeChangeLogs.
     * @return ApiResponse<kotlin.collections.List<CurveFeeChangeLogDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveFeeChangeLogsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveFeeChangeLogDTO>?> {
        val localVariableConfig = curveFeeChangeLogsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveFeeChangeLogDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveFeeChangeLogsCurrent
     *
     * @return RequestConfig
     */
    fun curveFeeChangeLogsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/feeChangeLogs/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeDeposits (current)
     * Gets gaugeDeposits.
     * @return kotlin.collections.List<CurveGaugeDepositDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeDepositsCurrent() : kotlin.collections.List<CurveGaugeDepositDTO> {
        val localVarResponse = curveGaugeDepositsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeDepositDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeDeposits (current)
     * Gets gaugeDeposits.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeDepositDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeDepositsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeDepositDTO>?> {
        val localVariableConfig = curveGaugeDepositsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeDepositDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeDepositsCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeDepositsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeDeposits/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeLiquidities (current)
     * Gets gaugeLiquidities.
     * @return kotlin.collections.List<CurveGaugeLiquidityDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeLiquiditiesCurrent() : kotlin.collections.List<CurveGaugeLiquidityDTO> {
        val localVarResponse = curveGaugeLiquiditiesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeLiquidityDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeLiquidities (current)
     * Gets gaugeLiquidities.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeLiquidityDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeLiquiditiesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeLiquidityDTO>?> {
        val localVariableConfig = curveGaugeLiquiditiesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeLiquidityDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeLiquiditiesCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeLiquiditiesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeLiquidities/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeTotalWeights (current)
     * Gets gaugeTotalWeights.
     * @return kotlin.collections.List<CurveGaugeTotalWeightDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeTotalWeightsCurrent() : kotlin.collections.List<CurveGaugeTotalWeightDTO> {
        val localVarResponse = curveGaugeTotalWeightsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeTotalWeightDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeTotalWeights (current)
     * Gets gaugeTotalWeights.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeTotalWeightDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeTotalWeightsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeTotalWeightDTO>?> {
        val localVariableConfig = curveGaugeTotalWeightsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeTotalWeightDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeTotalWeightsCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeTotalWeightsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeTotalWeights/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeTypeWeights (current)
     * Gets gaugeTypeWeights.
     * @return kotlin.collections.List<CurveGaugeTypeWeightDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeTypeWeightsCurrent() : kotlin.collections.List<CurveGaugeTypeWeightDTO> {
        val localVarResponse = curveGaugeTypeWeightsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeTypeWeightDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeTypeWeights (current)
     * Gets gaugeTypeWeights.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeTypeWeightDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeTypeWeightsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeTypeWeightDTO>?> {
        val localVariableConfig = curveGaugeTypeWeightsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeTypeWeightDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeTypeWeightsCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeTypeWeightsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeTypeWeights/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeTypes (current)
     * Gets gaugeTypes.
     * @return kotlin.collections.List<CurveGaugeTypeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeTypesCurrent() : kotlin.collections.List<CurveGaugeTypeDTO> {
        val localVarResponse = curveGaugeTypesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeTypeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeTypes (current)
     * Gets gaugeTypes.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeTypeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeTypesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeTypeDTO>?> {
        val localVariableConfig = curveGaugeTypesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeTypeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeTypesCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeTypesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeTypes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeWeightVotes (current)
     * Gets gaugeWeightVotes.
     * @return kotlin.collections.List<CurveGaugeWeightVoteDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeWeightVotesCurrent() : kotlin.collections.List<CurveGaugeWeightVoteDTO> {
        val localVarResponse = curveGaugeWeightVotesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeWeightVoteDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeWeightVotes (current)
     * Gets gaugeWeightVotes.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeWeightVoteDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeWeightVotesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeWeightVoteDTO>?> {
        val localVariableConfig = curveGaugeWeightVotesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeWeightVoteDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeWeightVotesCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeWeightVotesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeWeightVotes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeWeights (current)
     * Gets gaugeWeights.
     * @return kotlin.collections.List<CurveGaugeWeightDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeWeightsCurrent() : kotlin.collections.List<CurveGaugeWeightDTO> {
        val localVarResponse = curveGaugeWeightsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeWeightDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeWeights (current)
     * Gets gaugeWeights.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeWeightDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeWeightsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeWeightDTO>?> {
        val localVariableConfig = curveGaugeWeightsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeWeightDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeWeightsCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeWeightsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeWeights/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GaugeWithdraws (current)
     * Gets gaugeWithdraws.
     * @return kotlin.collections.List<CurveGaugeWithdrawDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugeWithdrawsCurrent() : kotlin.collections.List<CurveGaugeWithdrawDTO> {
        val localVarResponse = curveGaugeWithdrawsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeWithdrawDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GaugeWithdraws (current)
     * Gets gaugeWithdraws.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeWithdrawDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugeWithdrawsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeWithdrawDTO>?> {
        val localVariableConfig = curveGaugeWithdrawsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeWithdrawDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugeWithdrawsCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugeWithdrawsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gaugeWithdraws/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Gauges (current)
     * Gets gauges.
     * @return kotlin.collections.List<CurveGaugeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGaugesCurrent() : kotlin.collections.List<CurveGaugeDTO> {
        val localVarResponse = curveGaugesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveGaugeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Gauges (current)
     * Gets gauges.
     * @return ApiResponse<kotlin.collections.List<CurveGaugeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGaugesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveGaugeDTO>?> {
        val localVariableConfig = curveGaugesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveGaugeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGaugesCurrent
     *
     * @return RequestConfig
     */
    fun curveGaugesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/gauges/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * HourlyVolumes (current)
     * Gets hourlyVolumes.
     * @return kotlin.collections.List<CurveHourlyVolumeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveHourlyVolumesCurrent() : kotlin.collections.List<CurveHourlyVolumeDTO> {
        val localVarResponse = curveHourlyVolumesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveHourlyVolumeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * HourlyVolumes (current)
     * Gets hourlyVolumes.
     * @return ApiResponse<kotlin.collections.List<CurveHourlyVolumeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveHourlyVolumesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveHourlyVolumeDTO>?> {
        val localVariableConfig = curveHourlyVolumesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveHourlyVolumeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveHourlyVolumesCurrent
     *
     * @return RequestConfig
     */
    fun curveHourlyVolumesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/hourlyVolumes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * LpTokens (current)
     * Gets lpTokens.
     * @return kotlin.collections.List<CurveLpTokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveLpTokensCurrent() : kotlin.collections.List<CurveLpTokenDTO> {
        val localVarResponse = curveLpTokensCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveLpTokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * LpTokens (current)
     * Gets lpTokens.
     * @return ApiResponse<kotlin.collections.List<CurveLpTokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveLpTokensCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveLpTokenDTO>?> {
        val localVariableConfig = curveLpTokensCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveLpTokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveLpTokensCurrent
     *
     * @return RequestConfig
     */
    fun curveLpTokensCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/lpTokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Pools (current)
     * Gets pools.
     * @param id Pool address. (optional)
     * @return kotlin.collections.List<CurvePoolDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curvePoolsCurrent(id: kotlin.String? = null) : kotlin.collections.List<CurvePoolDTO> {
        val localVarResponse = curvePoolsCurrentWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurvePoolDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pools (current)
     * Gets pools.
     * @param id Pool address. (optional)
     * @return ApiResponse<kotlin.collections.List<CurvePoolDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curvePoolsCurrentWithHttpInfo(id: kotlin.String?) : ApiResponse<kotlin.collections.List<CurvePoolDTO>?> {
        val localVariableConfig = curvePoolsCurrentRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<CurvePoolDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curvePoolsCurrent
     *
     * @param id Pool address. (optional)
     * @return RequestConfig
     */
    fun curvePoolsCurrentRequestConfig(id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/pools/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * ProposalVotes (current)
     * Gets proposalVotes.
     * @return kotlin.collections.List<CurveProposalVoteDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveProposalVotesCurrent() : kotlin.collections.List<CurveProposalVoteDTO> {
        val localVarResponse = curveProposalVotesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveProposalVoteDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * ProposalVotes (current)
     * Gets proposalVotes.
     * @return ApiResponse<kotlin.collections.List<CurveProposalVoteDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveProposalVotesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveProposalVoteDTO>?> {
        val localVariableConfig = curveProposalVotesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveProposalVoteDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveProposalVotesCurrent
     *
     * @return RequestConfig
     */
    fun curveProposalVotesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/proposalVotes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Proposals (current)
     * Gets proposals.
     * @return kotlin.collections.List<CurveProposalDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveProposalsCurrent() : kotlin.collections.List<CurveProposalDTO> {
        val localVarResponse = curveProposalsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveProposalDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Proposals (current)
     * Gets proposals.
     * @return ApiResponse<kotlin.collections.List<CurveProposalDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveProposalsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveProposalDTO>?> {
        val localVariableConfig = curveProposalsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveProposalDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveProposalsCurrent
     *
     * @return RequestConfig
     */
    fun curveProposalsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/proposals/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * RemoveLiquidityEvents (current)
     * Gets removeLiquidityEvents.
     * @return kotlin.collections.List<CurveRemoveLiquidityEventDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveRemoveLiquidityEventsCurrent() : kotlin.collections.List<CurveRemoveLiquidityEventDTO> {
        val localVarResponse = curveRemoveLiquidityEventsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveRemoveLiquidityEventDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * RemoveLiquidityEvents (current)
     * Gets removeLiquidityEvents.
     * @return ApiResponse<kotlin.collections.List<CurveRemoveLiquidityEventDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveRemoveLiquidityEventsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveRemoveLiquidityEventDTO>?> {
        val localVariableConfig = curveRemoveLiquidityEventsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveRemoveLiquidityEventDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveRemoveLiquidityEventsCurrent
     *
     * @return RequestConfig
     */
    fun curveRemoveLiquidityEventsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/removeLiquidityEvents/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * RemoveLiquidityOneEvents (current)
     * Gets removeLiquidityOneEvents.
     * @return kotlin.collections.List<CurveRemoveLiquidityOneEventDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveRemoveLiquidityOneEventsCurrent() : kotlin.collections.List<CurveRemoveLiquidityOneEventDTO> {
        val localVarResponse = curveRemoveLiquidityOneEventsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveRemoveLiquidityOneEventDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * RemoveLiquidityOneEvents (current)
     * Gets removeLiquidityOneEvents.
     * @return ApiResponse<kotlin.collections.List<CurveRemoveLiquidityOneEventDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveRemoveLiquidityOneEventsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveRemoveLiquidityOneEventDTO>?> {
        val localVariableConfig = curveRemoveLiquidityOneEventsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveRemoveLiquidityOneEventDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveRemoveLiquidityOneEventsCurrent
     *
     * @return RequestConfig
     */
    fun curveRemoveLiquidityOneEventsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/removeLiquidityOneEvents/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * SystemStates (current)
     * Gets systemStates.
     * @return kotlin.collections.List<CurveSystemStateDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveSystemStatesCurrent() : kotlin.collections.List<CurveSystemStateDTO> {
        val localVarResponse = curveSystemStatesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveSystemStateDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * SystemStates (current)
     * Gets systemStates.
     * @return ApiResponse<kotlin.collections.List<CurveSystemStateDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveSystemStatesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveSystemStateDTO>?> {
        val localVariableConfig = curveSystemStatesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveSystemStateDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveSystemStatesCurrent
     *
     * @return RequestConfig
     */
    fun curveSystemStatesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/systemStates/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Tokens (current)
     * Gets tokens.
     * @return kotlin.collections.List<CurveTokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveTokensCurrent() : kotlin.collections.List<CurveTokenDTO> {
        val localVarResponse = curveTokensCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveTokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (current)
     * Gets tokens.
     * @return ApiResponse<kotlin.collections.List<CurveTokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveTokensCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveTokenDTO>?> {
        val localVariableConfig = curveTokensCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveTokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveTokensCurrent
     *
     * @return RequestConfig
     */
    fun curveTokensCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * TransferOwnershipEvents (current)
     * Gets transferOwnershipEvents.
     * @return kotlin.collections.List<CurveTransferOwnershipEventDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveTransferOwnershipEventsCurrent() : kotlin.collections.List<CurveTransferOwnershipEventDTO> {
        val localVarResponse = curveTransferOwnershipEventsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveTransferOwnershipEventDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TransferOwnershipEvents (current)
     * Gets transferOwnershipEvents.
     * @return ApiResponse<kotlin.collections.List<CurveTransferOwnershipEventDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveTransferOwnershipEventsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveTransferOwnershipEventDTO>?> {
        val localVariableConfig = curveTransferOwnershipEventsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveTransferOwnershipEventDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveTransferOwnershipEventsCurrent
     *
     * @return RequestConfig
     */
    fun curveTransferOwnershipEventsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/transferOwnershipEvents/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * UnderlyingCoins (current)
     * Gets underlyingCoins.
     * @return kotlin.collections.List<CurveUnderlyingCoinDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveUnderlyingCoinsCurrent() : kotlin.collections.List<CurveUnderlyingCoinDTO> {
        val localVarResponse = curveUnderlyingCoinsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveUnderlyingCoinDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * UnderlyingCoins (current)
     * Gets underlyingCoins.
     * @return ApiResponse<kotlin.collections.List<CurveUnderlyingCoinDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveUnderlyingCoinsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveUnderlyingCoinDTO>?> {
        val localVariableConfig = curveUnderlyingCoinsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveUnderlyingCoinDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveUnderlyingCoinsCurrent
     *
     * @return RequestConfig
     */
    fun curveUnderlyingCoinsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/underlyingCoins/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * VotingApps (current)
     * Gets votingApps.
     * @return kotlin.collections.List<CurveVotingAppDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveVotingAppsCurrent() : kotlin.collections.List<CurveVotingAppDTO> {
        val localVarResponse = curveVotingAppsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveVotingAppDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * VotingApps (current)
     * Gets votingApps.
     * @return ApiResponse<kotlin.collections.List<CurveVotingAppDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveVotingAppsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveVotingAppDTO>?> {
        val localVariableConfig = curveVotingAppsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveVotingAppDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveVotingAppsCurrent
     *
     * @return RequestConfig
     */
    fun curveVotingAppsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/votingApps/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * WeeklyVolumes (current)
     * Gets weeklyVolumes.
     * @return kotlin.collections.List<CurveWeeklyVolumeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveWeeklyVolumesCurrent() : kotlin.collections.List<CurveWeeklyVolumeDTO> {
        val localVarResponse = curveWeeklyVolumesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveWeeklyVolumeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * WeeklyVolumes (current)
     * Gets weeklyVolumes.
     * @return ApiResponse<kotlin.collections.List<CurveWeeklyVolumeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveWeeklyVolumesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveWeeklyVolumeDTO>?> {
        val localVariableConfig = curveWeeklyVolumesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveWeeklyVolumeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveWeeklyVolumesCurrent
     *
     * @return RequestConfig
     */
    fun curveWeeklyVolumesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/curve/weeklyVolumes/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
