// @flow
/* eslint-disable no-use-before-define */
/**
 * On Chain Dapps - REST API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSBidDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSBidDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    tokens_bid?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    bidder?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    buyer_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    seller_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_min_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_max_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSDataSourcesDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_range?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    causality_region?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    manifest_idx?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    parent?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    context?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    done_at?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSItemDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketPlaceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    schema_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    subgraph_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    methodology_version?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_unique_traders?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketplaceDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_unique_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_active_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    transaction_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    log_index?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    is_bundle?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    price_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    seller?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    id?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * Pool-level metadata.
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Smart contract address of the pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * The protocol this pool belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Tokens that need to be deposited to take a position in the protocol
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Token that is minted to track ownership of position in protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token?: string;
    /**
     * Aditional tokens that are given as reward for position in a protocol
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Whether this pool is single-sided
     * @type {boolean}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Evaluated ask value of the liquidity pool.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type UNISWAPV2ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Block number of this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * swap-{ Transaction hash }-{ Log index }
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Token deposited into pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UNISWAPV2ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * Smart contract address of the token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * amount of tokens in the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * Buffer for large price changes
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * Buffer for large TVL impacts
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_range?: string;
    /**
     * Account address.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * Number of positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    position_count?: number;
    /**
     * Number of open positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    closed_position_count?: number;
    /**
     * Number of deposits this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    withdraw_count?: number;
    /**
     * Number of times this account has traded/swapped.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    swap_count?: number;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type UNISWAPV3ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type UNISWAPV3ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    account?: string;
    /**
     * The user position changed by this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    position?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_upper?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type UNISWAPV3ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Number of cumulative liquidity providers.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_l_ps?: number;
    /**
     * Number of cumulative traders
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_traders?: number;
    /**
     * Total number of pools.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * Total number of open positions.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    open_position_count?: number;
    /**
     * Total number of positions (open and closed).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_block_number?: string;
    /**
     * This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.
     * @type {boolean}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    regenesis?: boolean;
}

/**
 * Daily financial metrics for Uniswap V3.
 * @export
 */
export type UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Block number of when this snapshot was taken/last modified.)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after the interval has passed).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    token_prices?: Array<string>;
}

/**
 * Pool-level metadata.
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Block range of the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * Protocol this pool belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Token that is to represent ownership of liquidity.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    liquidity_token?: string;
    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.).
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Specifies whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @type {boolean}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Timestamp when the liquidity pool was created.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Block number when the liquidity pool was created.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     *  All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    closed_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_block_number?: string;
    /**
     * Evaluated ask value of the liquidity pool.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Represents a liquidity pool daily snapshot for Uniswap V3.
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    vid?: number;
    /**
     * The Ethereum block number associated with the liquidity pool daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_?: number;
    /**
     * Identifier, format: (smart contract address of the pool)-(# of days since Unix epoch time).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol associated with the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Pool this snapshot belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All trade volume , in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     *  All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (fee type)-(pool address)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    vid?: number;
    /**
     * (Smart contract address of the pool)-( # of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hour?: number;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Number of positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    vid?: number;
    /**
     * (account address)-(market address)-(count)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    id?: string;
    /**
     * Account that owns this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    account?: string;
    /**
     * The liquidity pool in which this position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    pool?: string;
    /**
     * The hash of the transaction that opened this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_opened?: string;
    /**
     * The hash of the transaction that closed this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_closed?: string;
    /**
     * Block number of when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_opened?: string;
    /**
     * Timestamp when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_opened?: string;
    /**
     * Block number of when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_closed?: string;
    /**
     * Timestamp when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_closed?: string;
    /**
     * lower tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_lower?: string;
    /**
     * upper tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_upper?: string;
    /**
     * Token that is to represent ownership of liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    withdraw_count?: number;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    block_number?: number;
    /**
     *  (position id )-( transaction hash )-( log index ) 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    log_index?: number;
    /**
     * Nonce of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    nonce?: string;
    /**
     * Position of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    position?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in native amounts
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_token_amounts?: Array<string>;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    withdraw_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    timestamp?: string;
}

/**
 * Reward tokens awarded to lenders and borrowers.
 * @export
 */
export type UNISWAPV3ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type UNISWAPV3ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Block number in which the swap operation was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * Unique string identifier of the swap operation, format: (transaction hash)-(log index).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    account?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Tick of the swap operation.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    tick?: string;
    /**
     * Token deposited into pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    vid?: number;
    /**
     * (pool address)-(tick index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    id?: string;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    index?: string;
    /**
     * Liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    pool?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_block_number?: string;
    /**
     * calculated price of token0 of tick within this pool - constant
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    prices?: Array<string>;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net_usd?: string;
    /**
     * Day ID of the most recent daily snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_block_number?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    vid?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(day ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    day_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    vid?: number;
    /**
     * (pool address)-(tick index)-(hour ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    hour_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UNISWAPV3ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the token.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * Last pool that gave this token a price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_pool?: string;
    /**
     * Amount of tokens in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * The buffer for detecting large price changes.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * The buffer for detecting large TVL (Total Value Locked) impact.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    block_number?: number;
    /**
     * Whitelist Token Symbol
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    id?: string;
    /**
     * Whitelist Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    address?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Total number of deposits (add liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (# of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hour?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    account?: string;
    /**
     * The user position changed by this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    position?: string;
    /**
     * lower tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_lower?: string;
    /**
     * upper tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_upper?: string;
    /**
     * The pool involving this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity burned
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
}



/**
 * CRYPTOPUNKSApi - fetch parameter creator
 * @export
 */
export const CRYPTOPUNKSApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/bids/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/collectionDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/collections/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/dataSources/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/items/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/marketPlaces/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/marketplaceDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CRYPTOPUNKSApiType = { 
    cRYPTOPUNKSBidsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSBidDTO>>,

    cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>>,

    cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDTO>>,

    cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSDataSourcesDTO>>,

    cRYPTOPUNKSItemsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSItemDTO>>,

    cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>>,

    cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>>,

    cRYPTOPUNKSTradesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSTradeDTO>>,

    cRYPTOPUNKSUsersCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSUserDTO>>,
}

/**
 * CRYPTOPUNKSApi - factory function to inject configuration 
 * @export
 */
export const CRYPTOPUNKSApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CRYPTOPUNKSApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSBidDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSBidsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSDataSourcesDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSDataSourcesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSItemDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSItemsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketPlacesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSTradeDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSUserDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'dappName' is not null or undefined
            if (dappName === null || dappName === undefined) {
                throw new RequiredError('dappName','Required parameter dappName was null or undefined when calling metadataDappsDappNameGet.');
            }
            const localVarPath = `/metadata/dapps/{dappName}`
                .replace(`{${"dappName"}}`, encodeURIComponent(String(dappName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/dapps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    metadataChainsGet(options?: RequestOptions): Promise<Response>,

    metadataDappsDappNameGet(dappName: string, options?: RequestOptions): Promise<Response>,

    metadataDappsGet(options?: RequestOptions): Promise<Response>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataChainsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsDappNameGet(dappName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UNISWAPV2ETHEREUMApi - fetch parameter creator
 * @export
 */
export const UNISWAPV2ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UNISWAPV2ETHEREUMApiType = { 
    uNISWAPV2ETHEREUMLiquidityPoolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDTO>>,

    uNISWAPV2ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMSwapDTO>>,

    uNISWAPV2ETHEREUMTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMTokenDTO>>,
}

/**
 * UNISWAPV2ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const UNISWAPV2ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UNISWAPV2ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMSwapDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMTokenDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UNISWAPV3ETHEREUMApi - fetch parameter creator
 * @export
 */
export const UNISWAPV3ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tickDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tickHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokenWhiteListSymbols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UNISWAPV3ETHEREUMApiType = { 
    uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>>,

    uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>>,

    uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>>,

    uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>>,

    uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDTO>>,

    uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>>,

    uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>>,

    uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>>,

    uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>>,

    uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>>,

    uNISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>>,
}

/**
 * UNISWAPV3ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const UNISWAPV3ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UNISWAPV3ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTicksCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokensCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CRYPTOPUNKSApi: CRYPTOPUNKSApiType,

    MetadataApi: MetadataApiType,

    UNISWAPV2ETHEREUMApi: UNISWAPV2ETHEREUMApiType,

    UNISWAPV3ETHEREUMApi: UNISWAPV3ETHEREUMApiType,
 }
