// @flow
/* eslint-disable no-use-before-define */
/**
 * On Chain Dapps - REST API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSBidDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSBidDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    tokens_bid?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    bidder?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    buyer_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    seller_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_min_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_max_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSDataSourcesDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_range?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    causality_region?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    manifest_idx?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    parent?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    context?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    done_at?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSItemDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketPlaceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    schema_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    subgraph_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    methodology_version?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_unique_traders?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketplaceDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_unique_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_active_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    transaction_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    log_index?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    is_bundle?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    price_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    seller?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    id?: string;
}

/**
 * Entity to accumulate total unique users.
 * @export
 */
export type CURVEFINANCEETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * Address of the account
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMAccountDTO
     */
    block_range?: string;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type CURVEFINANCEETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMActiveAccountDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since Unix epoch)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMActiveAccountDTO
     */
    id?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type CURVEFINANCEETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    block_range?: string;
    /**
     * deposit-(Transaction hash)-(log index)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Output token of the pool. E.g. the UNI-LP token
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    output_token?: string;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of output tokens in the token\'s native unit
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    output_token_amount?: string;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDepositDTO
     */
    pool?: string;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type CURVEFINANCEETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * All pools that belong to this protocol
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMDexAmmProtocolDTO
     */
    pool_ids?: Array<string>;
}

/**
 * Daily financial metrics for Curve finance.
 * @export
 */
export type CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    block_range?: string;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMLiquidityGaugeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    block_range?: string;
    /**
     * Address of the Liquidity Gauge
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    id?: string;
    /**
     * Address of the pool associated with this liquidity gauge
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityGaugeDTO
     */
    pool_address?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Smart contract address of the pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * The protocol this pool belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * inputTokens in native (contract) order
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    input_tokens_ordered?: Array<string>;
    /**
     * Token that is minted to track ownership of position in protocol
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    output_token?: string;
    /**
     * Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.)
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @type {boolean}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Registry that deployed this pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    registry_address?: string;
    /**
     * Liquidity Gauge assocaited with this pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    gauge_address?: string;
    /**
     * 
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (smart contract address of the pool)-(# of days since Unix epoch time)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token. Note that certain DEXes don\'t have an output token (e.g. Bancor)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * (fee type)-(pool address)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_range?: string;
    /**
     * (smart contract address of the pool)-(# of hours since unix epoch time)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * All historical trade volume occurred in this pool, in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token. Note that certain DEXes don\'t have an output token (e.g. Bancor)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
}

/**
 * Entity for fetching the pool address from lpToken.
 * @export
 */
export type CURVEFINANCEETHEREUMLpTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    block_number?: number;
    /**
     * Address of the LP Token.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    id?: string;
    /**
     * Address of the pool associated with this token.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    pool_address?: string;
    /**
     * Address of the registry associated with this token.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMLpTokenDTO
     */
    registry_address?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token.
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Swap-(transaction hash)-(log index)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Token deposited into pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CURVEFINANCEETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * Smart contract address of the token
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in a day
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_range?: string;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Remove liquidity events.
 * @export
 */
export type CURVEFINANCEETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    block_range?: string;
    /**
     * withdraw-(transaction hash)-(log index)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    output_token?: string;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of output tokens in the token\'s native unit
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    output_token_amount?: string;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    amount_usd?: string;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof CURVEFINANCEETHEREUMWithdrawDTO
     */
    pool?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    block_range?: string;
    /**
     * Account address.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * Number of positions this account has.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    position_count?: number;
    /**
     * Number of open positions this account has.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions this account has.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    closed_position_count?: number;
    /**
     * Number of deposits this account made.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals this account made.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    withdraw_count?: number;
    /**
     * Number of times this account has traded/swapped.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMAccountDTO
     */
    swap_count?: number;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    account?: string;
    /**
     * The user position changed by this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    position?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    tick_upper?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Number of cumulative liquidity providers.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_l_ps?: number;
    /**
     * Number of cumulative traders
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_traders?: number;
    /**
     * Total number of pools.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * Total number of open positions.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    open_position_count?: number;
    /**
     * Total number of positions (open and closed).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_block_number?: string;
    /**
     * This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.
     * @type {boolean}
     * @memberof PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO
     */
    regenesis?: boolean;
}

/**
 * Daily financial metrics for PancakeSwap V3.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Block number of when this snapshot was taken/last modified.)
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after the interval has passed).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    token_prices?: Array<string>;
}

/**
 * Pool-level metadata.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Block range of the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * Protocol this pool belongs to.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Token that is to represent ownership of liquidity.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    liquidity_token?: string;
    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.).
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Specifies whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @type {boolean}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Timestamp when the liquidity pool was created.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Block number when the liquidity pool was created.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     *  All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    closed_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Represents a liquidity pool daily snapshot for PancakeSwap V3.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * The Ethereum block number associated with the liquidity pool daily snapshot.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_?: number;
    /**
     * Identifier, format: (smart contract address of the pool)-(# of days since Unix epoch time).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol associated with the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Pool this snapshot belongs to.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All trade volume , in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     *  All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in a day.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (fee type)-(pool address)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (Smart contract address of the pool)-( # of hours since Unix epoch time)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hour?: number;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity)
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity)
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps)
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Number of positions in this market
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    block_number?: number;
    /**
     * (account address)-(market address)-(count)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    id?: string;
    /**
     * Account that owns this position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    account?: string;
    /**
     * The liquidity pool in which this position was opened
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    pool?: string;
    /**
     * The hash of the transaction that opened this position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    hash_opened?: string;
    /**
     * The hash of the transaction that closed this position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    hash_closed?: string;
    /**
     * Block number of when the position was opened
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    block_number_opened?: string;
    /**
     * Timestamp when the position was opened
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    timestamp_opened?: string;
    /**
     * Block number of when the position was closed (0 if still open)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    block_number_closed?: string;
    /**
     * Timestamp when the position was closed (0 if still open)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    timestamp_closed?: string;
    /**
     * lower tick of the position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    tick_lower?: string;
    /**
     * upper tick of the position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    tick_upper?: string;
    /**
     * Token that is to represent ownership of liquidity
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    liquidity_token?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionDTO
     */
    withdraw_count?: number;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    block_number?: number;
    /**
     *  (position id )-( transaction hash )-( log index ) 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that triggered this snapshot
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    log_index?: number;
    /**
     * Nonce of the transaction that triggered this snapshot
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    nonce?: string;
    /**
     * Position of this snapshot
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    position?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in native amounts
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_token_amounts?: Array<string>;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    withdraw_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMPositionSnapshotDTO
     */
    timestamp?: string;
}

/**
 * Reward tokens awarded to lenders and borrowers.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Block number in which the swap operation was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * Unique string identifier of the swap operation, format: (transaction hash)-(log index).
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    account?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Tick of the swap operation.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    tick?: string;
    /**
     * Token deposited into pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof PANCAKESWAPV3ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    id?: string;
    /**
     * tick index
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    index?: string;
    /**
     * Liquidity pool this tick belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    pool?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    created_block_number?: string;
    /**
     * calculated price of token0 of tick within this pool - constant
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    prices?: Array<string>;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    liquidity_net_usd?: string;
    /**
     * Day ID of the most recent daily snapshot
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDTO
     */
    last_update_block_number?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(day ID)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    day_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)-(hour ID)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    hour_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the token.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * Last pool that gave this token a price.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    last_price_pool?: string;
    /**
     * Amount of tokens in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol.
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * The buffer for detecting large price changes.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * The buffer for detecting large TVL (Total Value Locked) impact.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * Token Address
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    block_number?: number;
    /**
     * Whitelist Token Symbol
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    id?: string;
    /**
     * Whitelist Token Address
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    address?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Total number of deposits (add liquidity) in an day
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an day
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an day
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (# of hours since Unix epoch time)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hour?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type PANCAKESWAPV3ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * (transaction hash)-(log index)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    account?: string;
    /**
     * The user position changed by this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    position?: string;
    /**
     * lower tick of position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    tick_lower?: string;
    /**
     * upper tick of position
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    tick_upper?: string;
    /**
     * The pool involving this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity burned
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof PANCAKESWAPV3ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    block_range?: string;
    /**
     * Account address.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * Number of positions this account has.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    position_count?: number;
    /**
     * Number of open positions this account has.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions this account has.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    closed_position_count?: number;
    /**
     * Number of deposits this account made.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals this account made.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    withdraw_count?: number;
    /**
     * Number of times this account has traded/swapped.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMAccountDTO
     */
    swap_count?: number;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type SUSHISWAPV3ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type SUSHISWAPV3ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    account?: string;
    /**
     * The user position changed by this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    position?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    tick_upper?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type SUSHISWAPV3ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Number of cumulative liquidity providers.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_l_ps?: number;
    /**
     * Number of cumulative traders
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_traders?: number;
    /**
     * Total number of pools.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * Total number of open positions.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    open_position_count?: number;
    /**
     * Total number of positions (open and closed).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_block_number?: string;
    /**
     * This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.
     * @type {boolean}
     * @memberof SUSHISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    regenesis?: boolean;
}

/**
 * Daily financial metrics for Sushiswap V3.
 * @export
 */
export type SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Block number of when this snapshot was taken/last modified.)
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after the interval has passed).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    token_prices?: Array<string>;
}

/**
 * Pool-level metadata.
 * @export
 */
export type SUSHISWAPV3ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Block range of the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * Protocol this pool belongs to.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Token that is to represent ownership of liquidity.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    liquidity_token?: string;
    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.).
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Specifies whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @type {boolean}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Timestamp when the liquidity pool was created.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Block number when the liquidity pool was created.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     *  All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    closed_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Represents a liquidity pool daily snapshot for Sushiswap V3.
 * @export
 */
export type SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * The Ethereum block number associated with the liquidity pool daily snapshot.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_?: number;
    /**
     * Identifier, format: (smart contract address of the pool)-(# of days since Unix epoch time).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol associated with the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Pool this snapshot belongs to.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All trade volume , in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     *  All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in a day.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (fee type)-(pool address)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (Smart contract address of the pool)-( # of hours since Unix epoch time)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hour?: number;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity)
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity)
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps)
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Number of positions in this market
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    block_number?: number;
    /**
     * (account address)-(market address)-(count)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    id?: string;
    /**
     * Account that owns this position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    account?: string;
    /**
     * The liquidity pool in which this position was opened
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    pool?: string;
    /**
     * The hash of the transaction that opened this position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    hash_opened?: string;
    /**
     * The hash of the transaction that closed this position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    hash_closed?: string;
    /**
     * Block number of when the position was opened
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    block_number_opened?: string;
    /**
     * Timestamp when the position was opened
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    timestamp_opened?: string;
    /**
     * Block number of when the position was closed (0 if still open)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    block_number_closed?: string;
    /**
     * Timestamp when the position was closed (0 if still open)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    timestamp_closed?: string;
    /**
     * lower tick of the position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    tick_lower?: string;
    /**
     * upper tick of the position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    tick_upper?: string;
    /**
     * Token that is to represent ownership of liquidity
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionDTO
     */
    withdraw_count?: number;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    block_number?: number;
    /**
     *  (position id )-( transaction hash )-( log index ) 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that triggered this snapshot
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    log_index?: number;
    /**
     * Nonce of the transaction that triggered this snapshot
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    nonce?: string;
    /**
     * Position of this snapshot
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    position?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in native amounts
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_token_amounts?: Array<string>;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    withdraw_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMPositionSnapshotDTO
     */
    timestamp?: string;
}

/**
 * Reward tokens awarded to lenders and borrowers.
 * @export
 */
export type SUSHISWAPV3ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type SUSHISWAPV3ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Block number in which the swap operation was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * Unique string identifier of the swap operation, format: (transaction hash)-(log index).
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    account?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Tick of the swap operation.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    tick?: string;
    /**
     * Token deposited into pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof SUSHISWAPV3ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMTickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    id?: string;
    /**
     * tick index
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    index?: string;
    /**
     * Liquidity pool this tick belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    pool?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    created_block_number?: string;
    /**
     * calculated price of token0 of tick within this pool - constant
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    prices?: Array<string>;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    liquidity_net_usd?: string;
    /**
     * Day ID of the most recent daily snapshot
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDTO
     */
    last_update_block_number?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMTickDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(day ID)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    day_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)-(hour ID)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    hour_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type SUSHISWAPV3ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the token.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * Last pool that gave this token a price.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    last_price_pool?: string;
    /**
     * Amount of tokens in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol.
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * The buffer for detecting large price changes.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * The buffer for detecting large TVL (Total Value Locked) impact.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * Token Address
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    block_number?: number;
    /**
     * Whitelist Token Symbol
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    id?: string;
    /**
     * Whitelist Token Address
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    address?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Total number of deposits (add liquidity) in an day
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an day
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an day
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (# of hours since Unix epoch time)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hour?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type SUSHISWAPV3ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * (transaction hash)-(log index)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    account?: string;
    /**
     * The user position changed by this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    position?: string;
    /**
     * lower tick of position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    tick_lower?: string;
    /**
     * upper tick of position
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    tick_upper?: string;
    /**
     * The pool involving this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity burned
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof SUSHISWAPV3ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    block_?: number;
    /**
     * Account address.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMAccountDTO
     */
    block_range?: string;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type UNISWAPV2ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    block_?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type UNISWAPV2ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Output token of the pool. E.g. the UNI-LP token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    output_token?: string;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of output tokens in the token\'s native unit
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    output_token_amount?: string;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type UNISWAPV2ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     *  Version of the subgraph schema, in SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
}

/**
 * Daily financial metrics for Uniswap V2.
 * @export
 */
export type UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    block_range?: string;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * ll revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    vid?: number;
    /**
     * .
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering is the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
}

/**
 * Pool-level metadata.
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Smart contract address of the pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * The protocol this pool belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Tokens that need to be deposited to take a position in the protocol
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Token that is minted to track ownership of position in protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token?: string;
    /**
     * Aditional tokens that are given as reward for position in a protocol
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Whether this pool is single-sided
     * @type {boolean}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Evaluated ask value of the liquidity pool.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Represents a liquidity pool daily snapshot for Uniswap V2.
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * .
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_range?: string;
    /**
     * (smart contract address of the pool)-(# of days since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field..
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token. Note that certain DEXes don\'t have an output token (e.g. Bancor).
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY..
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * (fee type)-(pool address)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_range?: string;
    /**
     * (smart contract address of the pool)-(# of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s \'inputTokens\' field.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * All historical trade volume occurred in this pool, in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output token. Note that certain DEXes don\'t have an output token (e.g. Bancor)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    output_token_supply?: string;
    /**
     * Price per share of output token in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    output_token_price_usd?: string;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
}

/**
 * .
 * @export
 */
export type UNISWAPV2ETHEREUMMasterChefAddressToPidDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (masterchef type) - (address of the staking pool per the masterchef pid)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    id?: string;
    /**
     * Pid referenced in the MasterChef Contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefAddressToPidDTO
     */
    pid?: string;
}

/**
 * Smart contract that is used to manage the liquidity mining program on Uniswap V2.
 * @export
 */
export type UNISWAPV2ETHEREUMMasterChefDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    block_range?: string;
    /**
     * (masterChef type) - (pid referenced in the masterchef contract)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    id?: string;
    /**
     * Address of the masterchef contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    address?: string;
    /**
     * Total allocation point of all staking pools
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    total_alloc_point?: string;
    /**
     * Amount of reward tokens emitted per block or timestamp
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    reward_token_rate?: string;
    /**
     * Indicates whether rewards are indicated by block or timestamp
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    reward_token_interval?: string;
    /**
     * Reward token rate given after you adjust for allocations either burned or not applicable
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    adjusted_reward_token_rate?: string;
    /**
     * Last time the adjusted reward token rate was updated
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefDTO
     */
    last_updated_reward_rate?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMMasterChefRewarderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    block_range?: string;
    /**
     * Address of the rewarder contract associated to some staking pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    id?: string;
    /**
     * Staking pool to which this rewarder is associated
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    pool?: string;
    /**
     * Address of the token given by this rewarder
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    reward_token?: string;
    /**
     * Number of tokens rewarded per second per LP staked in pool by this rewarder
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    token_per_sec?: string;
    /**
     * Timestamp from the last time tokenPerSec was calculated
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    rate_calculated_at?: string;
    /**
     * A field to keep track if there are any funds to give away in the rewarder
     * @type {boolean}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    has_funds?: boolean;
    /**
     * When it was last checked that there were funds in the rewarder
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    has_funds_at?: string;
    /**
     * If true it means the rewardRate can be retrieved directly from the contract, without crazy math
     * @type {boolean}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    can_retrieve_rate?: boolean;
    /**
     * Utility field to calculate the rewarder reward rate
     * @type {boolean}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    reward_rate_calculation_in_progress?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMMasterChefRewarderDTO
     */
    probes?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMMasterChefStakingPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    block_range?: string;
    /**
     * (masterchef type) - (pid referenced in the masterchef contract)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    id?: string;
    /**
     * Staking pool to which this rewarder is associated
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    pool_address?: string;
    /**
     * Allocation point of this MasterChef Staking pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    pool_alloc_point?: string;
    /**
     * Reward Multiplier for a given staking pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    multiplier?: string;
    /**
     * Last block where rewards were given out
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    last_reward_block?: string;
    /**
     * Optional address of a bonus rewarder, to give additional tokens on top of masterchefs
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMMasterChefStakingPoolDTO
     */
    rewarder?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    block_range?: string;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMRewarderProbeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    block_range?: string;
    /**
     * (rewarder)-(probeNum)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    id?: string;
    /**
     * The address being probed
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    user?: string;
    /**
     * The value from the last probe
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    pending?: string;
    /**
     * Block at which the probe was made
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    block_num?: string;
    /**
     * Block timestamp at whihc the probe was taken
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    timestamp?: string;
    /**
     * Total LP staked in pool at the time of the probe
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMRewarderProbeDTO
     */
    lp_staked?: string;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type UNISWAPV2ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * swap-(Transaction hash)-(Log index)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Token deposited into pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UNISWAPV2ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UNISWAPV2ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * Smart contract address of the token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * amount of tokens in the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * Buffer for large price changes
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * Buffer for large TVL impacts
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    block_range?: string;
    /**
     * Token Address
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMTransferDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    block_number?: number;
    /**
     * Entity is used to track data from the transfer events (execution of: deposit/withdraw, mint/burn).
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    block_range?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    sender?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMTransferDTO
     */
    liquidity?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_range?: string;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in a day
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_range?: string;
    /**
     * # of hours since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     *  Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV2ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    block_?: number;
    /**
     * Withdraw-(transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Address that received the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    to?: string;
    /**
     * Address that sent the tokens
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    from?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    output_token?: string;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of output tokens in the token\'s native unit
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    output_token_amount?: string;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
    /**
     * The pool involving this transaction
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV2ETHEREUMWithdrawDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_range?: string;
    /**
     * Account address.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * Number of positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    position_count?: number;
    /**
     * Number of open positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    closed_position_count?: number;
    /**
     * Number of deposits this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    withdraw_count?: number;
    /**
     * Number of times this account has traded/swapped.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    swap_count?: number;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type UNISWAPV3ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type UNISWAPV3ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    account?: string;
    /**
     * The user position changed by this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    position?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_upper?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type UNISWAPV3ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Number of cumulative liquidity providers.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_l_ps?: number;
    /**
     * Number of cumulative traders
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_traders?: number;
    /**
     * Total number of pools.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * Total number of open positions.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    open_position_count?: number;
    /**
     * Total number of positions (open and closed).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_block_number?: string;
    /**
     * This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.
     * @type {boolean}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    regenesis?: boolean;
}

/**
 * Daily financial metrics for Uniswap V3.
 * @export
 */
export type UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after the interval has passed).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    token_prices?: Array<string>;
}

/**
 * Pool-level metadata.
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    vid?: number;
    /**
     * Block range of the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    id?: string;
    /**
     * Protocol this pool belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    protocol?: string;
    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    name?: string;
    /**
     * Symbol of liquidity pool (e.g. 3CRV).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    symbol?: string;
    /**
     * Token that is to represent ownership of liquidity.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    liquidity_token?: string;
    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_tokens?: Array<string>;
    /**
     * Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_tokens?: Array<string>;
    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.).
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    fees?: Array<string>;
    /**
     * Specifies whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @type {boolean}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    is_single_sided?: boolean;
    /**
     * Timestamp when the liquidity pool was created.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_timestamp?: string;
    /**
     * Block number when the liquidity pool was created.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    created_block_number?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     *  All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    cumulative_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    closed_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    last_update_block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Represents a liquidity pool daily snapshot for Uniswap V3.
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_number?: number;
    /**
     * The Ethereum block number associated with the liquidity pool daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    block_?: number;
    /**
     * Identifier, format: (smart contract address of the pool)-(# of days since Unix epoch time).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol associated with the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Pool this snapshot belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * Sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Daily revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All trade volume , in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     *  All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in a day.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Number of positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (fee type)-(pool address)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (Smart contract address of the pool)-( # of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hour?: number;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Number of positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number?: number;
    /**
     * (account address)-(market address)-(count)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    id?: string;
    /**
     * Account that owns this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    account?: string;
    /**
     * The liquidity pool in which this position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    pool?: string;
    /**
     * The hash of the transaction that opened this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_opened?: string;
    /**
     * The hash of the transaction that closed this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_closed?: string;
    /**
     * Block number of when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_opened?: string;
    /**
     * Timestamp when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_opened?: string;
    /**
     * Block number of when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_closed?: string;
    /**
     * Timestamp when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_closed?: string;
    /**
     * lower tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_lower?: string;
    /**
     * upper tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_upper?: string;
    /**
     * Token that is to represent ownership of liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    withdraw_count?: number;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    block_number?: number;
    /**
     *  (position id )-( transaction hash )-( log index ) 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    log_index?: number;
    /**
     * Nonce of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    nonce?: string;
    /**
     * Position of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    position?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in native amounts
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_token_amounts?: Array<string>;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    withdraw_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    timestamp?: string;
}

/**
 * Reward tokens awarded to lenders and borrowers.
 * @export
 */
export type UNISWAPV3ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * Trade (swap) event which occurred in a pool.
 * @export
 */
export type UNISWAPV3ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Block number in which the swap operation was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * Unique string identifier of the swap operation, format: (transaction hash)-(log index).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    account?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Tick of the swap operation.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    tick?: string;
    /**
     * Token deposited into pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    id?: string;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    index?: string;
    /**
     * Liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    pool?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_block_number?: string;
    /**
     * calculated price of token0 of tick within this pool - constant
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    prices?: Array<string>;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net_usd?: string;
    /**
     * Day ID of the most recent daily snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_block_number?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(day ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    day_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (pool address)-(tick index)-(hour ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    hour_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UNISWAPV3ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the token.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * Last pool that gave this token a price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_pool?: string;
    /**
     * Amount of tokens in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * The buffer for detecting large price changes.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * The buffer for detecting large TVL (Total Value Locked) impact.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    block_number?: number;
    /**
     * Whitelist Token Symbol
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    id?: string;
    /**
     * Whitelist Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    address?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Total number of deposits (add liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (# of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hour?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    account?: string;
    /**
     * The user position changed by this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    position?: string;
    /**
     * lower tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_lower?: string;
    /**
     * upper tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_upper?: string;
    /**
     * The pool involving this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity burned
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
}



/**
 * CRYPTOPUNKSETHEREUMApi - fetch parameter creator
 * @export
 */
export const CRYPTOPUNKSETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMBidsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/bids/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/collectionDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMCollectionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/collections/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMDataSourcesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/dataSources/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMItemsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/items/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMMarketPlacesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/marketPlaces/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/marketplaceDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/cryptopunks-ethereum/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CRYPTOPUNKSETHEREUMApiType = { 
    cRYPTOPUNKSETHEREUMBidsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSBidDTO>>,

    cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>>,

    cRYPTOPUNKSETHEREUMCollectionsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDTO>>,

    cRYPTOPUNKSETHEREUMDataSourcesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSDataSourcesDTO>>,

    cRYPTOPUNKSETHEREUMItemsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSItemDTO>>,

    cRYPTOPUNKSETHEREUMMarketPlacesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>>,

    cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>>,

    cRYPTOPUNKSETHEREUMTradesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSTradeDTO>>,

    cRYPTOPUNKSETHEREUMUsersCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSUserDTO>>,
}

/**
 * CRYPTOPUNKSETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const CRYPTOPUNKSETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CRYPTOPUNKSETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMBidsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSBidDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMBidsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMCollectionsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMCollectionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMDataSourcesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSDataSourcesDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMDataSourcesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMItemsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSItemDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMItemsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMMarketPlacesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMMarketPlacesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMTradesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSTradeDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSETHEREUMUsersCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSUserDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSETHEREUMApiFetchParamCreator(configuration).cRYPTOPUNKSETHEREUMUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CURVEFINANCEETHEREUMApi - fetch parameter creator
 * @export
 */
export const CURVEFINANCEETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityGauges.
         * @summary LiquidityGauges (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityGaugesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/liquidityGauges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLpTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/lpTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMTokensCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/curve-finance-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CURVEFINANCEETHEREUMApiType = { 
    cURVEFINANCEETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMAccountDTO>>,

    cURVEFINANCEETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMActiveAccountDTO>>,

    cURVEFINANCEETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMDepositDTO>>,

    cURVEFINANCEETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMDexAmmProtocolDTO>>,

    cURVEFINANCEETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO>>,

    cURVEFINANCEETHEREUMLiquidityGaugesCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLiquidityGaugeDTO>>,

    cURVEFINANCEETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO>>,

    cURVEFINANCEETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolFeeDTO>>,

    cURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    cURVEFINANCEETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolDTO>>,

    cURVEFINANCEETHEREUMLpTokensCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMLpTokenDTO>>,

    cURVEFINANCEETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMRewardTokenDTO>>,

    cURVEFINANCEETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMSwapDTO>>,

    cURVEFINANCEETHEREUMTokensCurrent(id?: string, options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMTokenDTO>>,

    cURVEFINANCEETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO>>,

    cURVEFINANCEETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO>>,

    cURVEFINANCEETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<CURVEFINANCEETHEREUMWithdrawDTO>>,
}

/**
 * CURVEFINANCEETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const CURVEFINANCEETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CURVEFINANCEETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMAccountDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMDepositDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityGauges.
         * @summary LiquidityGauges (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityGaugesCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLiquidityGaugeDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLiquidityGaugesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLiquidityPoolDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLiquidityPoolHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMLpTokensCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMLpTokenDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMLpTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMSwapDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMTokensCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMTokenDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMTokensCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        cURVEFINANCEETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<CURVEFINANCEETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = CURVEFINANCEETHEREUMApiFetchParamCreator(configuration).cURVEFINANCEETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets chain by chainId.
         * @throws {RequiredError}
         */
        metadataChainsChainIdGet(chainId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'chainId' is not null or undefined
            if (chainId === null || chainId === undefined) {
                throw new RequiredError('chainId','Required parameter chainId was null or undefined when calling metadataChainsChainIdGet.');
            }
            const localVarPath = `/metadata/chains/{chainId}`
                .replace(`{${"chainId"}}`, encodeURIComponent(String(chainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets dapp by id.
         * @throws {RequiredError}
         */
        metadataDappsDappIdGet(dappId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling metadataDappsDappIdGet.');
            }
            const localVarPath = `/metadata/dapps/{dappId}`
                .replace(`{${"dappId"}}`, encodeURIComponent(String(dappId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/dapps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    metadataChainsChainIdGet(chainId: string, options?: RequestOptions): Promise<Response>,

    metadataChainsGet(options?: RequestOptions): Promise<Response>,

    metadataDappsDappIdGet(dappId: string, options?: RequestOptions): Promise<Response>,

    metadataDappsGet(options?: RequestOptions): Promise<Response>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Gets chain by chainId.
         * @throws {RequiredError}
         */
        metadataChainsChainIdGet(chainId: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataChainsChainIdGet(chainId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataChainsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Gets dapp by id.
         * @throws {RequiredError}
         */
        metadataDappsDappIdGet(dappId: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsDappIdGet(dappId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PANCAKESWAPV3ETHEREUMApi - fetch parameter creator
 * @export
 */
export const PANCAKESWAPV3ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMPositionsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/tickDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/tickHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTicksCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/tokenWhiteListSymbols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokensCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/pancakeswap-v3-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PANCAKESWAPV3ETHEREUMApiType = { 
    pANCAKESWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMAccountDTO>>,

    pANCAKESWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMActiveAccountDTO>>,

    pANCAKESWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMDepositDTO>>,

    pANCAKESWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO>>,

    pANCAKESWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO>>,

    pANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO>>,

    pANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolDTO>>,

    pANCAKESWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMPositionSnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMPositionDTO>>,

    pANCAKESWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMRewardTokenDTO>>,

    pANCAKESWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMSwapDTO>>,

    pANCAKESWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTickDTO>>,

    pANCAKESWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO>>,

    pANCAKESWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTokenWhiteListDTO>>,

    pANCAKESWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMTokenDTO>>,

    pANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    pANCAKESWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<PANCAKESWAPV3ETHEREUMWithdrawDTO>>,
}

/**
 * PANCAKESWAPV3ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const PANCAKESWAPV3ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PANCAKESWAPV3ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMAccountDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMDepositDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMPositionSnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMPositionDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMPositionsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMSwapDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTickDailySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTickDailySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTickHourlySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTickDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTicksCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTokenWhiteListSymbolDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMTokenDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMTokensCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        pANCAKESWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<PANCAKESWAPV3ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = PANCAKESWAPV3ETHEREUMApiFetchParamCreator(configuration).pANCAKESWAPV3ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SUSHISWAPV3ETHEREUMApi - fetch parameter creator
 * @export
 */
export const SUSHISWAPV3ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMPositionsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/tickDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/tickHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTicksCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/tokenWhiteListSymbols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokensCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/sushiswap-v3-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SUSHISWAPV3ETHEREUMApiType = { 
    sUSHISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMAccountDTO>>,

    sUSHISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMActiveAccountDTO>>,

    sUSHISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMDepositDTO>>,

    sUSHISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMDexAmmProtocolDTO>>,

    sUSHISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO>>,

    sUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO>>,

    sUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolDTO>>,

    sUSHISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMPositionSnapshotDTO>>,

    sUSHISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMPositionDTO>>,

    sUSHISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMRewardTokenDTO>>,

    sUSHISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMSwapDTO>>,

    sUSHISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTickDailySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTickDTO>>,

    sUSHISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO>>,

    sUSHISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTokenWhiteListDTO>>,

    sUSHISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMTokenDTO>>,

    sUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    sUSHISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<SUSHISWAPV3ETHEREUMWithdrawDTO>>,
}

/**
 * SUSHISWAPV3ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const SUSHISWAPV3ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SUSHISWAPV3ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMAccountDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMDepositDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMPositionSnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMPositionDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMPositionsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMSwapDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTickDailySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTickDailySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTickHourlySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTickDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTicksCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTokenWhiteListSymbolDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMTokenDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMTokensCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        sUSHISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<SUSHISWAPV3ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = SUSHISWAPV3ETHEREUMApiFetchParamCreator(configuration).sUSHISWAPV3ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UNISWAPV2ETHEREUMApi - fetch parameter creator
 * @export
 */
export const UNISWAPV2ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets masterChefAddressToPids.
         * @summary MasterChefAddressToPids (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefAddressToPidsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/masterChefAddressToPids/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets masterChefRewarders.
         * @summary MasterChefRewarders (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefRewardersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/masterChefRewarders/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets masterChefStakingPools.
         * @summary MasterChefStakingPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefStakingPoolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/masterChefStakingPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets masterChefs.
         * @summary MasterChefs (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/masterChefs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewarderProbes.
         * @summary RewarderProbes (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMRewarderProbesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/rewarderProbes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transfers.
         * @summary Transfers (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTransfersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/transfers/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v2-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UNISWAPV2ETHEREUMApiType = { 
    uNISWAPV2ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMAccountDTO>>,

    uNISWAPV2ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMActiveAccountDTO>>,

    uNISWAPV2ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMDepositDTO>>,

    uNISWAPV2ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMDexAmmProtocolDTO>>,

    uNISWAPV2ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO>>,

    uNISWAPV2ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolAmountDTO>>,

    uNISWAPV2ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO>>,

    uNISWAPV2ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolFeeDTO>>,

    uNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    uNISWAPV2ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDTO>>,

    uNISWAPV2ETHEREUMMasterChefAddressToPidsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMMasterChefAddressToPidDTO>>,

    uNISWAPV2ETHEREUMMasterChefRewardersCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMMasterChefRewarderDTO>>,

    uNISWAPV2ETHEREUMMasterChefStakingPoolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMMasterChefStakingPoolDTO>>,

    uNISWAPV2ETHEREUMMasterChefsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMMasterChefDTO>>,

    uNISWAPV2ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMRewardTokenDTO>>,

    uNISWAPV2ETHEREUMRewarderProbesCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMRewarderProbeDTO>>,

    uNISWAPV2ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMSwapDTO>>,

    uNISWAPV2ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMTokenWhiteListDTO>>,

    uNISWAPV2ETHEREUMTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMTokenDTO>>,

    uNISWAPV2ETHEREUMTransfersCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMTransferDTO>>,

    uNISWAPV2ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO>>,

    uNISWAPV2ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    uNISWAPV2ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV2ETHEREUMWithdrawDTO>>,
}

/**
 * UNISWAPV2ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const UNISWAPV2ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UNISWAPV2ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMAccountDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMDepositDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolAmountsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets masterChefAddressToPids.
         * @summary MasterChefAddressToPids (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefAddressToPidsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMMasterChefAddressToPidDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMMasterChefAddressToPidsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets masterChefRewarders.
         * @summary MasterChefRewarders (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefRewardersCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMMasterChefRewarderDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMMasterChefRewardersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets masterChefStakingPools.
         * @summary MasterChefStakingPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefStakingPoolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMMasterChefStakingPoolDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMMasterChefStakingPoolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets masterChefs.
         * @summary MasterChefs (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMMasterChefsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMMasterChefDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMMasterChefsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewarderProbes.
         * @summary RewarderProbes (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMRewarderProbesCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMRewarderProbeDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMRewarderProbesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMSwapDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMTokenDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transfers.
         * @summary Transfers (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMTransfersCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMTransferDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMTransfersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV2ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV2ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = UNISWAPV2ETHEREUMApiFetchParamCreator(configuration).uNISWAPV2ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UNISWAPV3ETHEREUMApi - fetch parameter creator
 * @export
 */
export const UNISWAPV3ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/liquidityPools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tickDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tickHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokenWhiteListSymbols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/dapps/uniswap-v3-ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UNISWAPV3ETHEREUMApiType = { 
    uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>>,

    uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>>,

    uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>>,

    uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>>,

    uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDTO>>,

    uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>>,

    uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>>,

    uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>>,

    uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>>,

    uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMTicksCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>>,

    uNISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>>,
}

/**
 * UNISWAPV3ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const UNISWAPV3ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UNISWAPV3ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolDailySnapshots.
         * @summary LiquidityPoolDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolDailySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPools.
         * @summary LiquidityPools (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTicksCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokensCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CRYPTOPUNKSETHEREUMApi: CRYPTOPUNKSETHEREUMApiType,

    CURVEFINANCEETHEREUMApi: CURVEFINANCEETHEREUMApiType,

    MetadataApi: MetadataApiType,

    PANCAKESWAPV3ETHEREUMApi: PANCAKESWAPV3ETHEREUMApiType,

    SUSHISWAPV3ETHEREUMApi: SUSHISWAPV3ETHEREUMApiType,

    UNISWAPV2ETHEREUMApi: UNISWAPV2ETHEREUMApiType,

    UNISWAPV3ETHEREUMApi: UNISWAPV3ETHEREUMApiType,
 }
