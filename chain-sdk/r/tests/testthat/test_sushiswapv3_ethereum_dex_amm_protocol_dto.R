# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test SUSHISWAPV3ETHEREUMDexAmmProtocolDTO")

model_instance <- SUSHISWAPV3ETHEREUMDexAmmProtocolDTO$new()

test_that("entry_time", {
  # tests for the property `entry_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`entry_time`, "EXPECTED_RESULT")
})

test_that("recv_time", {
  # tests for the property `recv_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`recv_time`, "EXPECTED_RESULT")
})

test_that("block_number", {
  # tests for the property `block_number` (integer)
  # Number of block in which entity was recorded.

  # uncomment below to test the property
  #expect_equal(model.instance$`block_number`, "EXPECTED_RESULT")
})

test_that("block_range", {
  # tests for the property `block_range` (character)
  # 

  # uncomment below to test the property
  #expect_equal(model.instance$`block_range`, "EXPECTED_RESULT")
})

test_that("id", {
  # tests for the property `id` (character)
  # Smart contract address of the protocol&#39;s main contract (Factory, Registry, etc).

  # uncomment below to test the property
  #expect_equal(model.instance$`id`, "EXPECTED_RESULT")
})

test_that("name", {
  # tests for the property `name` (character)
  # Name of the protocol, including version. e.g. Uniswap v3.

  # uncomment below to test the property
  #expect_equal(model.instance$`name`, "EXPECTED_RESULT")
})

test_that("slug", {
  # tests for the property `slug` (character)
  # Slug of protocol, including version. e.g. uniswap-v3.

  # uncomment below to test the property
  #expect_equal(model.instance$`slug`, "EXPECTED_RESULT")
})

test_that("schema_version", {
  # tests for the property `schema_version` (character)
  # Version of the subgraph schema, in SemVer format (e.g. 1.0.0).

  # uncomment below to test the property
  #expect_equal(model.instance$`schema_version`, "EXPECTED_RESULT")
})

test_that("subgraph_version", {
  # tests for the property `subgraph_version` (character)
  # Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).

  # uncomment below to test the property
  #expect_equal(model.instance$`subgraph_version`, "EXPECTED_RESULT")
})

test_that("methodology_version", {
  # tests for the property `methodology_version` (character)
  # Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).

  # uncomment below to test the property
  #expect_equal(model.instance$`methodology_version`, "EXPECTED_RESULT")
})

test_that("total_value_locked_usd", {
  # tests for the property `total_value_locked_usd` (character)
  # Current TVL (Total Value Locked) of the entire protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_value_locked_usd`, "EXPECTED_RESULT")
})

test_that("total_liquidity_usd", {
  # tests for the property `total_liquidity_usd` (character)
  # The sum of all active and non-active liquidity in USD for this pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_liquidity_usd`, "EXPECTED_RESULT")
})

test_that("active_liquidity_usd", {
  # tests for the property `active_liquidity_usd` (character)
  # All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.

  # uncomment below to test the property
  #expect_equal(model.instance$`active_liquidity_usd`, "EXPECTED_RESULT")
})

test_that("uncollected_protocol_side_value_usd", {
  # tests for the property `uncollected_protocol_side_value_usd` (character)
  # All protocol-side value locking in USD that remains uncollected and unused in the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_protocol_side_value_usd`, "EXPECTED_RESULT")
})

test_that("uncollected_supply_side_value_usd", {
  # tests for the property `uncollected_supply_side_value_usd` (character)
  # All supply-side value locking in USD that remains uncollected and unused in the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_supply_side_value_usd`, "EXPECTED_RESULT")
})

test_that("protocol_controlled_value_usd", {
  # tests for the property `protocol_controlled_value_usd` (character)
  # Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.

  # uncomment below to test the property
  #expect_equal(model.instance$`protocol_controlled_value_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_volume_usd", {
  # tests for the property `cumulative_volume_usd` (character)
  # All historical volume in USD.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_volume_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_supply_side_revenue_usd", {
  # tests for the property `cumulative_supply_side_revenue_usd` (character)
  # Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_supply_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_protocol_side_revenue_usd", {
  # tests for the property `cumulative_protocol_side_revenue_usd` (character)
  # Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushiâ€™s 0.05%). OpenSea 10% sell fee.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_protocol_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_total_revenue_usd", {
  # tests for the property `cumulative_total_revenue_usd` (character)
  # All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_total_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_unique_users", {
  # tests for the property `cumulative_unique_users` (integer)
  # Number of cumulative unique users.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_unique_users`, "EXPECTED_RESULT")
})

test_that("cumulative_unique_l_ps", {
  # tests for the property `cumulative_unique_l_ps` (integer)
  # Number of cumulative liquidity providers.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_unique_l_ps`, "EXPECTED_RESULT")
})

test_that("cumulative_unique_traders", {
  # tests for the property `cumulative_unique_traders` (integer)
  # Number of cumulative traders

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_unique_traders`, "EXPECTED_RESULT")
})

test_that("total_pool_count", {
  # tests for the property `total_pool_count` (integer)
  # Total number of pools.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_pool_count`, "EXPECTED_RESULT")
})

test_that("open_position_count", {
  # tests for the property `open_position_count` (integer)
  # Total number of open positions.

  # uncomment below to test the property
  #expect_equal(model.instance$`open_position_count`, "EXPECTED_RESULT")
})

test_that("cumulative_position_count", {
  # tests for the property `cumulative_position_count` (integer)
  # Total number of positions (open and closed).

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_position_count`, "EXPECTED_RESULT")
})

test_that("last_snapshot_day_id", {
  # tests for the property `last_snapshot_day_id` (integer)
  # Day ID of the most recent daily snapshot.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_snapshot_day_id`, "EXPECTED_RESULT")
})

test_that("last_update_timestamp", {
  # tests for the property `last_update_timestamp` (character)
  # Timestamp of the last time this entity was updated

  # uncomment below to test the property
  #expect_equal(model.instance$`last_update_timestamp`, "EXPECTED_RESULT")
})

test_that("last_update_block_number", {
  # tests for the property `last_update_block_number` (character)
  # Block number of the last time this entity was updated.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_update_block_number`, "EXPECTED_RESULT")
})

test_that("regenesis", {
  # tests for the property `regenesis` (character)
  # This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.

  # uncomment below to test the property
  #expect_equal(model.instance$`regenesis`, "EXPECTED_RESULT")
})
