# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test CURVEFINANCEETHEREUMLiquidityPoolDTO")

model_instance <- CURVEFINANCEETHEREUMLiquidityPoolDTO$new()

test_that("entry_time", {
  # tests for the property `entry_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`entry_time`, "EXPECTED_RESULT")
})

test_that("recv_time", {
  # tests for the property `recv_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`recv_time`, "EXPECTED_RESULT")
})

test_that("block_number", {
  # tests for the property `block_number` (integer)
  # Number of block in which entity was recorded.

  # uncomment below to test the property
  #expect_equal(model.instance$`block_number`, "EXPECTED_RESULT")
})

test_that("vid", {
  # tests for the property `vid` (integer)
  # 

  # uncomment below to test the property
  #expect_equal(model.instance$`vid`, "EXPECTED_RESULT")
})

test_that("id", {
  # tests for the property `id` (character)
  # Smart contract address of the pool

  # uncomment below to test the property
  #expect_equal(model.instance$`id`, "EXPECTED_RESULT")
})

test_that("protocol", {
  # tests for the property `protocol` (character)
  # The protocol this pool belongs to

  # uncomment below to test the property
  #expect_equal(model.instance$`protocol`, "EXPECTED_RESULT")
})

test_that("name", {
  # tests for the property `name` (character)
  # Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)

  # uncomment below to test the property
  #expect_equal(model.instance$`name`, "EXPECTED_RESULT")
})

test_that("symbol", {
  # tests for the property `symbol` (character)
  # Symbol of liquidity pool (e.g. 3CRV)

  # uncomment below to test the property
  #expect_equal(model.instance$`symbol`, "EXPECTED_RESULT")
})

test_that("input_tokens", {
  # tests for the property `input_tokens` (array[character])
  # Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer

  # uncomment below to test the property
  #expect_equal(model.instance$`input_tokens`, "EXPECTED_RESULT")
})

test_that("input_tokens_ordered", {
  # tests for the property `input_tokens_ordered` (array[character])
  # inputTokens in native (contract) order

  # uncomment below to test the property
  #expect_equal(model.instance$`input_tokens_ordered`, "EXPECTED_RESULT")
})

test_that("output_token", {
  # tests for the property `output_token` (character)
  # Token that is minted to track ownership of position in protocol

  # uncomment below to test the property
  #expect_equal(model.instance$`output_token`, "EXPECTED_RESULT")
})

test_that("reward_tokens", {
  # tests for the property `reward_tokens` (array[character])
  # Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_tokens`, "EXPECTED_RESULT")
})

test_that("fees", {
  # tests for the property `fees` (array[character])
  # Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.)

  # uncomment below to test the property
  #expect_equal(model.instance$`fees`, "EXPECTED_RESULT")
})

test_that("is_single_sided", {
  # tests for the property `is_single_sided` (character)
  # Whether this pool is single-sided (e.g. Bancor, Platypus&#39;s Alternative Pool). The specifics of the implementation depends on the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`is_single_sided`, "EXPECTED_RESULT")
})

test_that("created_timestamp", {
  # tests for the property `created_timestamp` (character)
  # Creation timestamp

  # uncomment below to test the property
  #expect_equal(model.instance$`created_timestamp`, "EXPECTED_RESULT")
})

test_that("created_block_number", {
  # tests for the property `created_block_number` (character)
  # Creation block number

  # uncomment below to test the property
  #expect_equal(model.instance$`created_block_number`, "EXPECTED_RESULT")
})

test_that("total_value_locked_usd", {
  # tests for the property `total_value_locked_usd` (character)
  # Current TVL (Total Value Locked) of this pool in USD

  # uncomment below to test the property
  #expect_equal(model.instance$`total_value_locked_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_supply_side_revenue_usd", {
  # tests for the property `cumulative_supply_side_revenue_usd` (character)
  # All revenue generated by the liquidity pool, accrued to the supply side.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_supply_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_protocol_side_revenue_usd", {
  # tests for the property `cumulative_protocol_side_revenue_usd` (character)
  # All revenue generated by the liquidity pool, accrued to the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_protocol_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_total_revenue_usd", {
  # tests for the property `cumulative_total_revenue_usd` (character)
  # All revenue generated by the liquidity pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_total_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_volume_usd", {
  # tests for the property `cumulative_volume_usd` (character)
  # All historical trade volume occurred in this pool, in USD

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_volume_usd`, "EXPECTED_RESULT")
})

test_that("input_token_balances", {
  # tests for the property `input_token_balances` (array[character])
  # Amount of input tokens in the pool. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_token_balances`, "EXPECTED_RESULT")
})

test_that("input_token_weights", {
  # tests for the property `input_token_weights` (array[character])
  # Weights of input tokens in the liquidity pool in percentage values.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_token_weights`, "EXPECTED_RESULT")
})

test_that("output_token_supply", {
  # tests for the property `output_token_supply` (character)
  # Total supply of output token.

  # uncomment below to test the property
  #expect_equal(model.instance$`output_token_supply`, "EXPECTED_RESULT")
})

test_that("output_token_price_usd", {
  # tests for the property `output_token_price_usd` (character)
  # Price per share of output token in USD

  # uncomment below to test the property
  #expect_equal(model.instance$`output_token_price_usd`, "EXPECTED_RESULT")
})

test_that("staked_output_token_amount", {
  # tests for the property `staked_output_token_amount` (character)
  # Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.

  # uncomment below to test the property
  #expect_equal(model.instance$`staked_output_token_amount`, "EXPECTED_RESULT")
})

test_that("reward_token_emissions_amount", {
  # tests for the property `reward_token_emissions_amount` (array[character])
  # Per-block reward token emission as of the current block normalized to a day, in token&#39;s native amount.

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_token_emissions_amount`, "EXPECTED_RESULT")
})

test_that("reward_token_emissions_usd", {
  # tests for the property `reward_token_emissions_usd` (array[character])
  # Per-block reward token emission as of the current block normalized to a day, in USD value.

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_token_emissions_usd`, "EXPECTED_RESULT")
})

test_that("registry_address", {
  # tests for the property `registry_address` (character)
  # Registry that deployed this pool

  # uncomment below to test the property
  #expect_equal(model.instance$`registry_address`, "EXPECTED_RESULT")
})

test_that("gauge_address", {
  # tests for the property `gauge_address` (character)
  # Liquidity Gauge assocaited with this pool

  # uncomment below to test the property
  #expect_equal(model.instance$`gauge_address`, "EXPECTED_RESULT")
})

test_that("evaluated_ask", {
  # tests for the property `evaluated_ask` (numeric)

  # uncomment below to test the property
  #expect_equal(model.instance$`evaluated_ask`, "EXPECTED_RESULT")
})
