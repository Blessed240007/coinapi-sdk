# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test SUSHISWAPV3ETHEREUMLiquidityPoolDTO")

model_instance <- SUSHISWAPV3ETHEREUMLiquidityPoolDTO$new()

test_that("entry_time", {
  # tests for the property `entry_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`entry_time`, "EXPECTED_RESULT")
})

test_that("recv_time", {
  # tests for the property `recv_time` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`recv_time`, "EXPECTED_RESULT")
})

test_that("block_number", {
  # tests for the property `block_number` (integer)
  # Number of block in which entity was recorded.

  # uncomment below to test the property
  #expect_equal(model.instance$`block_number`, "EXPECTED_RESULT")
})

test_that("vid", {
  # tests for the property `vid` (integer)
  # .

  # uncomment below to test the property
  #expect_equal(model.instance$`vid`, "EXPECTED_RESULT")
})

test_that("block_range", {
  # tests for the property `block_range` (character)
  # Block range of the liquidity pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`block_range`, "EXPECTED_RESULT")
})

test_that("id", {
  # tests for the property `id` (character)
  # Smart contract address of the pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`id`, "EXPECTED_RESULT")
})

test_that("protocol", {
  # tests for the property `protocol` (character)
  # Protocol this pool belongs to.

  # uncomment below to test the property
  #expect_equal(model.instance$`protocol`, "EXPECTED_RESULT")
})

test_that("name", {
  # tests for the property `name` (character)
  # Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT).

  # uncomment below to test the property
  #expect_equal(model.instance$`name`, "EXPECTED_RESULT")
})

test_that("symbol", {
  # tests for the property `symbol` (character)
  # Symbol of liquidity pool (e.g. 3CRV).

  # uncomment below to test the property
  #expect_equal(model.instance$`symbol`, "EXPECTED_RESULT")
})

test_that("liquidity_token", {
  # tests for the property `liquidity_token` (character)
  # Token that is to represent ownership of liquidity.

  # uncomment below to test the property
  #expect_equal(model.instance$`liquidity_token`, "EXPECTED_RESULT")
})

test_that("input_tokens", {
  # tests for the property `input_tokens` (array[character])
  # Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_tokens`, "EXPECTED_RESULT")
})

test_that("reward_tokens", {
  # tests for the property `reward_tokens` (array[character])
  # Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon.

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_tokens`, "EXPECTED_RESULT")
})

test_that("fees", {
  # tests for the property `fees` (array[character])
  # Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.).

  # uncomment below to test the property
  #expect_equal(model.instance$`fees`, "EXPECTED_RESULT")
})

test_that("is_single_sided", {
  # tests for the property `is_single_sided` (character)
  # Specifies whether this pool is single-sided (e.g. Bancor, Platypus&#39;s Alternative Pool). The specifics of the implementation depends on the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`is_single_sided`, "EXPECTED_RESULT")
})

test_that("created_timestamp", {
  # tests for the property `created_timestamp` (character)
  # Timestamp when the liquidity pool was created.

  # uncomment below to test the property
  #expect_equal(model.instance$`created_timestamp`, "EXPECTED_RESULT")
})

test_that("created_block_number", {
  # tests for the property `created_block_number` (character)
  # Block number when the liquidity pool was created.

  # uncomment below to test the property
  #expect_equal(model.instance$`created_block_number`, "EXPECTED_RESULT")
})

test_that("tick", {
  # tests for the property `tick` (character)
  # Current tick representing the price of token0/token1.

  # uncomment below to test the property
  #expect_equal(model.instance$`tick`, "EXPECTED_RESULT")
})

test_that("total_value_locked_usd", {
  # tests for the property `total_value_locked_usd` (character)
  # Current TVL (Total Value Locked) of this pool in USD.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_value_locked_usd`, "EXPECTED_RESULT")
})

test_that("total_liquidity", {
  # tests for the property `total_liquidity` (character)
  # Sum of all active and non-active liquidity for this pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_liquidity`, "EXPECTED_RESULT")
})

test_that("total_liquidity_usd", {
  # tests for the property `total_liquidity_usd` (character)
  # Sum of all active and non-active liquidity in USD for this pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`total_liquidity_usd`, "EXPECTED_RESULT")
})

test_that("active_liquidity", {
  # tests for the property `active_liquidity` (character)
  # All liquidity &#x60;k&#x60; that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.

  # uncomment below to test the property
  #expect_equal(model.instance$`active_liquidity`, "EXPECTED_RESULT")
})

test_that("active_liquidity_usd", {
  # tests for the property `active_liquidity_usd` (character)
  # All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.

  # uncomment below to test the property
  #expect_equal(model.instance$`active_liquidity_usd`, "EXPECTED_RESULT")
})

test_that("uncollected_protocol_side_token_amounts", {
  # tests for the property `uncollected_protocol_side_token_amounts` (array[character])
  # All protocol-side value locked in token amounts that remains uncollected and unused in the pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_protocol_side_token_amounts`, "EXPECTED_RESULT")
})

test_that("uncollected_protocol_side_values_usd", {
  # tests for the property `uncollected_protocol_side_values_usd` (array[character])
  # All protocol-side value locking in USD that remains uncollected and unused in the pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_protocol_side_values_usd`, "EXPECTED_RESULT")
})

test_that("uncollected_supply_side_token_amounts", {
  # tests for the property `uncollected_supply_side_token_amounts` (array[character])
  # All supply-side value locked in token amounts that remains uncollected and unused in the pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_supply_side_token_amounts`, "EXPECTED_RESULT")
})

test_that("uncollected_supply_side_values_usd", {
  # tests for the property `uncollected_supply_side_values_usd` (array[character])
  # All supply-side value locked in USD that remains uncollected and unused in the pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`uncollected_supply_side_values_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_supply_side_revenue_usd", {
  # tests for the property `cumulative_supply_side_revenue_usd` (character)
  # All revenue generated by the liquidity pool, accrued to the supply side.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_supply_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_protocol_side_revenue_usd", {
  # tests for the property `cumulative_protocol_side_revenue_usd` (character)
  # All revenue generated by the liquidity pool, accrued to the protocol.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_protocol_side_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_total_revenue_usd", {
  # tests for the property `cumulative_total_revenue_usd` (character)
  #  All revenue generated by the liquidity pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_total_revenue_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_volume_by_token_amount", {
  # tests for the property `cumulative_volume_by_token_amount` (array[character])
  # All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_volume_by_token_amount`, "EXPECTED_RESULT")
})

test_that("cumulative_volume_by_token_usd", {
  # tests for the property `cumulative_volume_by_token_usd` (array[character])
  # All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_volume_by_token_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_volume_usd", {
  # tests for the property `cumulative_volume_usd` (character)
  # All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_volume_usd`, "EXPECTED_RESULT")
})

test_that("input_token_balances", {
  # tests for the property `input_token_balances` (array[character])
  # Amount of input tokens in the pool. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_token_balances`, "EXPECTED_RESULT")
})

test_that("input_token_balances_usd", {
  # tests for the property `input_token_balances_usd` (array[character])
  # Amount of input tokens in USD in the pool. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_token_balances_usd`, "EXPECTED_RESULT")
})

test_that("input_token_weights", {
  # tests for the property `input_token_weights` (array[character])
  # Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_token_weights`, "EXPECTED_RESULT")
})

test_that("staked_output_token_amount", {
  # tests for the property `staked_output_token_amount` (character)
  # Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.

  # uncomment below to test the property
  #expect_equal(model.instance$`staked_output_token_amount`, "EXPECTED_RESULT")
})

test_that("reward_token_emissions_amount", {
  # tests for the property `reward_token_emissions_amount` (array[character])
  # Per-block reward token emission as of the current block normalized to a day, in token&#39;s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_token_emissions_amount`, "EXPECTED_RESULT")
})

test_that("reward_token_emissions_usd", {
  # tests for the property `reward_token_emissions_usd` (array[character])
  # Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.

  # uncomment below to test the property
  #expect_equal(model.instance$`reward_token_emissions_usd`, "EXPECTED_RESULT")
})

test_that("cumulative_deposit_count", {
  # tests for the property `cumulative_deposit_count` (integer)
  # Total number of deposits (add liquidity).

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_deposit_count`, "EXPECTED_RESULT")
})

test_that("cumulative_withdraw_count", {
  # tests for the property `cumulative_withdraw_count` (integer)
  # Total number of withdrawals (remove liquidity).

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_withdraw_count`, "EXPECTED_RESULT")
})

test_that("cumulative_swap_count", {
  # tests for the property `cumulative_swap_count` (integer)
  # Total number of trades (swaps).

  # uncomment below to test the property
  #expect_equal(model.instance$`cumulative_swap_count`, "EXPECTED_RESULT")
})

test_that("position_count", {
  # tests for the property `position_count` (integer)
  # Number of positions in this market.

  # uncomment below to test the property
  #expect_equal(model.instance$`position_count`, "EXPECTED_RESULT")
})

test_that("open_position_count", {
  # tests for the property `open_position_count` (integer)
  # Number of open positions in this market.

  # uncomment below to test the property
  #expect_equal(model.instance$`open_position_count`, "EXPECTED_RESULT")
})

test_that("closed_position_count", {
  # tests for the property `closed_position_count` (integer)
  # Number of closed positions in this market.

  # uncomment below to test the property
  #expect_equal(model.instance$`closed_position_count`, "EXPECTED_RESULT")
})

test_that("last_snapshot_day_id", {
  # tests for the property `last_snapshot_day_id` (integer)
  # Day ID of the most recent daily snapshot.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_snapshot_day_id`, "EXPECTED_RESULT")
})

test_that("last_snapshot_hour_id", {
  # tests for the property `last_snapshot_hour_id` (integer)
  # Hour ID of the most recent hourly snapshot.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_snapshot_hour_id`, "EXPECTED_RESULT")
})

test_that("last_update_timestamp", {
  # tests for the property `last_update_timestamp` (character)
  # Timestamp of the last time this entity was updated.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_update_timestamp`, "EXPECTED_RESULT")
})

test_that("last_update_block_number", {
  # tests for the property `last_update_block_number` (character)
  # Block number of the last time this entity was updated.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_update_block_number`, "EXPECTED_RESULT")
})

test_that("evaluated_ask", {
  # tests for the property `evaluated_ask` (numeric)
  # 

  # uncomment below to test the property
  #expect_equal(model.instance$`evaluated_ask`, "EXPECTED_RESULT")
})
