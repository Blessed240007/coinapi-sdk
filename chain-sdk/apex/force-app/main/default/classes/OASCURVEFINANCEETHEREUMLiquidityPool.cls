/*
 * On Chain Dapps - REST API
 * \nThis section will provide necessary information about the `OnChain API` protocol. \n<br/><br/>\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.        \n                    
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by the OAS code generator program.
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

/**
 * 
 */
public class OASCURVEFINANCEETHEREUMLiquidityPool implements OAS.MappedProperties {
    /**
     * Get entryTime
     * @return entryTime
     */
    public Datetime entryTime { get; set; }

    /**
     * Get recvTime
     * @return recvTime
     */
    public Datetime recvTime { get; set; }

    /**
     * Number of block in which entity was recorded.
     * @return blockNumber
     */
    public Long blockNumber { get; set; }

    /**
     * 
     * @return vid
     */
    public Long vid { get; set; }

    /**
     * Smart contract address of the pool
     * @return id
     */
    public String id { get; set; }

    /**
     * The protocol this pool belongs to
     * @return protocol
     */
    public String protocol { get; set; }

    /**
     * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)
     * @return name
     */
    public String name { get; set; }

    /**
     * Symbol of liquidity pool (e.g. 3CRV)
     * @return symbol
     */
    public String symbol { get; set; }

    /**
     * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer
     * @return inputTokens
     */
    public List<String> inputTokens { get; set; }

    /**
     * inputTokens in native (contract) order
     * @return inputTokensOrdered
     */
    public List<String> inputTokensOrdered { get; set; }

    /**
     * Token that is minted to track ownership of position in protocol
     * @return outputToken
     */
    public String outputToken { get; set; }

    /**
     * Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon
     * @return rewardTokens
     */
    public List<String> rewardTokens { get; set; }

    /**
     * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.)
     * @return fees
     */
    public List<String> fees { get; set; }

    /**
     * Whether this pool is single-sided (e.g. Bancor, Platypus\'s Alternative Pool). The specifics of the implementation depends on the protocol.
     * @return isSingleSided
     */
    public Boolean isSingleSided { get; set; }

    /**
     * Creation timestamp
     * @return createdTimestamp
     */
    public String createdTimestamp { get; set; }

    /**
     * Creation block number
     * @return createdBlockNumber
     */
    public String createdBlockNumber { get; set; }

    /**
     * Current TVL (Total Value Locked) of this pool in USD
     * @return totalValueLockedUsd
     */
    public String totalValueLockedUsd { get; set; }

    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @return cumulativeSupplySideRevenueUsd
     */
    public String cumulativeSupplySideRevenueUsd { get; set; }

    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @return cumulativeProtocolSideRevenueUsd
     */
    public String cumulativeProtocolSideRevenueUsd { get; set; }

    /**
     * All revenue generated by the liquidity pool.
     * @return cumulativeTotalRevenueUsd
     */
    public String cumulativeTotalRevenueUsd { get; set; }

    /**
     * All historical trade volume occurred in this pool, in USD
     * @return cumulativeVolumeUsd
     */
    public String cumulativeVolumeUsd { get; set; }

    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @return inputTokenBalances
     */
    public List<String> inputTokenBalances { get; set; }

    /**
     * Weights of input tokens in the liquidity pool in percentage values.
     * @return inputTokenWeights
     */
    public List<String> inputTokenWeights { get; set; }

    /**
     * Total supply of output token.
     * @return outputTokenSupply
     */
    public String outputTokenSupply { get; set; }

    /**
     * Price per share of output token in USD
     * @return outputTokenPriceUsd
     */
    public String outputTokenPriceUsd { get; set; }

    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @return stakedOutputTokenAmount
     */
    public String stakedOutputTokenAmount { get; set; }

    /**
     * Per-block reward token emission as of the current block normalized to a day, in token\'s native amount.
     * @return rewardTokenEmissionsAmount
     */
    public List<String> rewardTokenEmissionsAmount { get; set; }

    /**
     * Per-block reward token emission as of the current block normalized to a day, in USD value.
     * @return rewardTokenEmissionsUsd
     */
    public List<String> rewardTokenEmissionsUsd { get; set; }

    /**
     * Registry that deployed this pool
     * @return registryAddress
     */
    public String registryAddress { get; set; }

    /**
     * Liquidity Gauge assocaited with this pool
     * @return gaugeAddress
     */
    public String gaugeAddress { get; set; }

    /**
     * Get evaluatedAsk
     * @return evaluatedAsk
     */
    public Double evaluatedAsk { get; private set; }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    private static final Map<String, String> propertyMappings = new Map<String, String>{
        'entry_time' => 'entryTime',
        'recv_time' => 'recvTime',
        'block_number' => 'blockNumber',
        'input_tokens' => 'inputTokens',
        'input_tokens_ordered' => 'inputTokensOrdered',
        'output_token' => 'outputToken',
        'reward_tokens' => 'rewardTokens',
        'is_single_sided' => 'isSingleSided',
        'created_timestamp' => 'createdTimestamp',
        'created_block_number' => 'createdBlockNumber',
        'total_value_locked_usd' => 'totalValueLockedUsd',
        'cumulative_supply_side_revenue_usd' => 'cumulativeSupplySideRevenueUsd',
        'cumulative_protocol_side_revenue_usd' => 'cumulativeProtocolSideRevenueUsd',
        'cumulative_total_revenue_usd' => 'cumulativeTotalRevenueUsd',
        'cumulative_volume_usd' => 'cumulativeVolumeUsd',
        'input_token_balances' => 'inputTokenBalances',
        'input_token_weights' => 'inputTokenWeights',
        'output_token_supply' => 'outputTokenSupply',
        'output_token_price_usd' => 'outputTokenPriceUsd',
        'staked_output_token_amount' => 'stakedOutputTokenAmount',
        'reward_token_emissions_amount' => 'rewardTokenEmissionsAmount',
        'reward_token_emissions_usd' => 'rewardTokenEmissionsUsd',
        'registry_address' => 'registryAddress',
        'gauge_address' => 'gaugeAddress',
        'evaluated_ask' => 'evaluatedAsk'
    };

    public Map<String, String> getPropertyMappings() {
        return propertyMappings;
    }

    public OASCURVEFINANCEETHEREUMLiquidityPool() {
        inputTokens = new List<String>();
        inputTokensOrdered = new List<String>();
        rewardTokens = new List<String>();
        fees = new List<String>();
        inputTokenBalances = new List<String>();
        inputTokenWeights = new List<String>();
        rewardTokenEmissionsAmount = new List<String>();
        rewardTokenEmissionsUsd = new List<String>();
    }

    public static OASCURVEFINANCEETHEREUMLiquidityPool getExample() {
        OASCURVEFINANCEETHEREUMLiquidityPool cuRVEFINANCEETHEREUMLiquidityPoolDTO = new OASCURVEFINANCEETHEREUMLiquidityPool();
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.entryTime = Datetime.newInstanceGmt(2000, 1, 23, 4, 56, 7);
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.recvTime = Datetime.newInstanceGmt(2000, 1, 23, 4, 56, 7);
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.blockNumber = 123456789L;
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.vid = 123456789L;
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.id = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.protocol = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.name = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.symbol = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokens = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokensOrdered = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputToken = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokens = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.fees = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.isSingleSided = true;
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdTimestamp = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdBlockNumber = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.totalValueLockedUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeSupplySideRevenueUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeProtocolSideRevenueUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeTotalRevenueUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeVolumeUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenBalances = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenWeights = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenSupply = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenPriceUsd = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.stakedOutputTokenAmount = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsAmount = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsUsd = new List<String>{''};
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.registryAddress = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.gaugeAddress = '';
          cuRVEFINANCEETHEREUMLiquidityPoolDTO.evaluatedAsk = 1.3579;
        return cuRVEFINANCEETHEREUMLiquidityPoolDTO;
    }

    public Boolean equals(Object obj) {
        if (obj instanceof OASCURVEFINANCEETHEREUMLiquidityPool) {           
            OASCURVEFINANCEETHEREUMLiquidityPool cuRVEFINANCEETHEREUMLiquidityPoolDTO = (OASCURVEFINANCEETHEREUMLiquidityPool) obj;
            return this.entryTime == cuRVEFINANCEETHEREUMLiquidityPoolDTO.entryTime
                && this.recvTime == cuRVEFINANCEETHEREUMLiquidityPoolDTO.recvTime
                && this.blockNumber == cuRVEFINANCEETHEREUMLiquidityPoolDTO.blockNumber
                && this.vid == cuRVEFINANCEETHEREUMLiquidityPoolDTO.vid
                && this.id == cuRVEFINANCEETHEREUMLiquidityPoolDTO.id
                && this.protocol == cuRVEFINANCEETHEREUMLiquidityPoolDTO.protocol
                && this.name == cuRVEFINANCEETHEREUMLiquidityPoolDTO.name
                && this.symbol == cuRVEFINANCEETHEREUMLiquidityPoolDTO.symbol
                && this.inputTokens == cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokens
                && this.inputTokensOrdered == cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokensOrdered
                && this.outputToken == cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputToken
                && this.rewardTokens == cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokens
                && this.fees == cuRVEFINANCEETHEREUMLiquidityPoolDTO.fees
                && this.isSingleSided == cuRVEFINANCEETHEREUMLiquidityPoolDTO.isSingleSided
                && this.createdTimestamp == cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdTimestamp
                && this.createdBlockNumber == cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdBlockNumber
                && this.totalValueLockedUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.totalValueLockedUsd
                && this.cumulativeSupplySideRevenueUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeSupplySideRevenueUsd
                && this.cumulativeProtocolSideRevenueUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeProtocolSideRevenueUsd
                && this.cumulativeTotalRevenueUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeTotalRevenueUsd
                && this.cumulativeVolumeUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeVolumeUsd
                && this.inputTokenBalances == cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenBalances
                && this.inputTokenWeights == cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenWeights
                && this.outputTokenSupply == cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenSupply
                && this.outputTokenPriceUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenPriceUsd
                && this.stakedOutputTokenAmount == cuRVEFINANCEETHEREUMLiquidityPoolDTO.stakedOutputTokenAmount
                && this.rewardTokenEmissionsAmount == cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsAmount
                && this.rewardTokenEmissionsUsd == cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsUsd
                && this.registryAddress == cuRVEFINANCEETHEREUMLiquidityPoolDTO.registryAddress
                && this.gaugeAddress == cuRVEFINANCEETHEREUMLiquidityPoolDTO.gaugeAddress
                && this.evaluatedAsk == cuRVEFINANCEETHEREUMLiquidityPoolDTO.evaluatedAsk;
        }
        return false;
    }

    public Integer hashCode() {
        Integer hashCode = 43;
        hashCode = (17 * hashCode) + (entryTime == null ? 0 : System.hashCode(entryTime));
        hashCode = (17 * hashCode) + (recvTime == null ? 0 : System.hashCode(recvTime));
        hashCode = (17 * hashCode) + (blockNumber == null ? 0 : System.hashCode(blockNumber));
        hashCode = (17 * hashCode) + (vid == null ? 0 : System.hashCode(vid));
        hashCode = (17 * hashCode) + (id == null ? 0 : System.hashCode(id));
        hashCode = (17 * hashCode) + (protocol == null ? 0 : System.hashCode(protocol));
        hashCode = (17 * hashCode) + (name == null ? 0 : System.hashCode(name));
        hashCode = (17 * hashCode) + (symbol == null ? 0 : System.hashCode(symbol));
        hashCode = (17 * hashCode) + (inputTokens == null ? 0 : System.hashCode(inputTokens));
        hashCode = (17 * hashCode) + (inputTokensOrdered == null ? 0 : System.hashCode(inputTokensOrdered));
        hashCode = (17 * hashCode) + (outputToken == null ? 0 : System.hashCode(outputToken));
        hashCode = (17 * hashCode) + (rewardTokens == null ? 0 : System.hashCode(rewardTokens));
        hashCode = (17 * hashCode) + (fees == null ? 0 : System.hashCode(fees));
        hashCode = (17 * hashCode) + (isSingleSided == null ? 0 : System.hashCode(isSingleSided));
        hashCode = (17 * hashCode) + (createdTimestamp == null ? 0 : System.hashCode(createdTimestamp));
        hashCode = (17 * hashCode) + (createdBlockNumber == null ? 0 : System.hashCode(createdBlockNumber));
        hashCode = (17 * hashCode) + (totalValueLockedUsd == null ? 0 : System.hashCode(totalValueLockedUsd));
        hashCode = (17 * hashCode) + (cumulativeSupplySideRevenueUsd == null ? 0 : System.hashCode(cumulativeSupplySideRevenueUsd));
        hashCode = (17 * hashCode) + (cumulativeProtocolSideRevenueUsd == null ? 0 : System.hashCode(cumulativeProtocolSideRevenueUsd));
        hashCode = (17 * hashCode) + (cumulativeTotalRevenueUsd == null ? 0 : System.hashCode(cumulativeTotalRevenueUsd));
        hashCode = (17 * hashCode) + (cumulativeVolumeUsd == null ? 0 : System.hashCode(cumulativeVolumeUsd));
        hashCode = (17 * hashCode) + (inputTokenBalances == null ? 0 : System.hashCode(inputTokenBalances));
        hashCode = (17 * hashCode) + (inputTokenWeights == null ? 0 : System.hashCode(inputTokenWeights));
        hashCode = (17 * hashCode) + (outputTokenSupply == null ? 0 : System.hashCode(outputTokenSupply));
        hashCode = (17 * hashCode) + (outputTokenPriceUsd == null ? 0 : System.hashCode(outputTokenPriceUsd));
        hashCode = (17 * hashCode) + (stakedOutputTokenAmount == null ? 0 : System.hashCode(stakedOutputTokenAmount));
        hashCode = (17 * hashCode) + (rewardTokenEmissionsAmount == null ? 0 : System.hashCode(rewardTokenEmissionsAmount));
        hashCode = (17 * hashCode) + (rewardTokenEmissionsUsd == null ? 0 : System.hashCode(rewardTokenEmissionsUsd));
        hashCode = (17 * hashCode) + (registryAddress == null ? 0 : System.hashCode(registryAddress));
        hashCode = (17 * hashCode) + (gaugeAddress == null ? 0 : System.hashCode(gaugeAddress));
        hashCode = (17 * hashCode) + (evaluatedAsk == null ? 0 : System.hashCode(evaluatedAsk));
        return hashCode;
    }
}

