/*
 * On Chain Dapps - REST API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-24T12:57:58.978232Z[Etc/UTC]")
public class CURVEFINANCEETHEREUMLiquidityPoolDTO {
  public static final String SERIALIZED_NAME_ENTRY_TIME = "entry_time";
  @SerializedName(SERIALIZED_NAME_ENTRY_TIME)
  private OffsetDateTime entryTime;

  public static final String SERIALIZED_NAME_RECV_TIME = "recv_time";
  @SerializedName(SERIALIZED_NAME_RECV_TIME)
  private OffsetDateTime recvTime;

  public static final String SERIALIZED_NAME_BLOCK_NUMBER = "block_number";
  @SerializedName(SERIALIZED_NAME_BLOCK_NUMBER)
  private Long blockNumber;

  public static final String SERIALIZED_NAME_VID = "vid";
  @SerializedName(SERIALIZED_NAME_VID)
  private Long vid;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  private String protocol;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  private String symbol;

  public static final String SERIALIZED_NAME_INPUT_TOKENS = "input_tokens";
  @SerializedName(SERIALIZED_NAME_INPUT_TOKENS)
  private List<String> inputTokens;

  public static final String SERIALIZED_NAME_INPUT_TOKENS_ORDERED = "input_tokens_ordered";
  @SerializedName(SERIALIZED_NAME_INPUT_TOKENS_ORDERED)
  private List<String> inputTokensOrdered;

  public static final String SERIALIZED_NAME_OUTPUT_TOKEN = "output_token";
  @SerializedName(SERIALIZED_NAME_OUTPUT_TOKEN)
  private String outputToken;

  public static final String SERIALIZED_NAME_REWARD_TOKENS = "reward_tokens";
  @SerializedName(SERIALIZED_NAME_REWARD_TOKENS)
  private List<String> rewardTokens;

  public static final String SERIALIZED_NAME_FEES = "fees";
  @SerializedName(SERIALIZED_NAME_FEES)
  private List<String> fees;

  public static final String SERIALIZED_NAME_IS_SINGLE_SIDED = "is_single_sided";
  @SerializedName(SERIALIZED_NAME_IS_SINGLE_SIDED)
  private Boolean isSingleSided;

  public static final String SERIALIZED_NAME_CREATED_TIMESTAMP = "created_timestamp";
  @SerializedName(SERIALIZED_NAME_CREATED_TIMESTAMP)
  private String createdTimestamp;

  public static final String SERIALIZED_NAME_CREATED_BLOCK_NUMBER = "created_block_number";
  @SerializedName(SERIALIZED_NAME_CREATED_BLOCK_NUMBER)
  private String createdBlockNumber;

  public static final String SERIALIZED_NAME_TOTAL_VALUE_LOCKED_USD = "total_value_locked_usd";
  @SerializedName(SERIALIZED_NAME_TOTAL_VALUE_LOCKED_USD)
  private String totalValueLockedUsd;

  public static final String SERIALIZED_NAME_CUMULATIVE_SUPPLY_SIDE_REVENUE_USD = "cumulative_supply_side_revenue_usd";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE_SUPPLY_SIDE_REVENUE_USD)
  private String cumulativeSupplySideRevenueUsd;

  public static final String SERIALIZED_NAME_CUMULATIVE_PROTOCOL_SIDE_REVENUE_USD = "cumulative_protocol_side_revenue_usd";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE_PROTOCOL_SIDE_REVENUE_USD)
  private String cumulativeProtocolSideRevenueUsd;

  public static final String SERIALIZED_NAME_CUMULATIVE_TOTAL_REVENUE_USD = "cumulative_total_revenue_usd";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE_TOTAL_REVENUE_USD)
  private String cumulativeTotalRevenueUsd;

  public static final String SERIALIZED_NAME_CUMULATIVE_VOLUME_USD = "cumulative_volume_usd";
  @SerializedName(SERIALIZED_NAME_CUMULATIVE_VOLUME_USD)
  private String cumulativeVolumeUsd;

  public static final String SERIALIZED_NAME_INPUT_TOKEN_BALANCES = "input_token_balances";
  @SerializedName(SERIALIZED_NAME_INPUT_TOKEN_BALANCES)
  private List<String> inputTokenBalances;

  public static final String SERIALIZED_NAME_INPUT_TOKEN_WEIGHTS = "input_token_weights";
  @SerializedName(SERIALIZED_NAME_INPUT_TOKEN_WEIGHTS)
  private List<String> inputTokenWeights;

  public static final String SERIALIZED_NAME_OUTPUT_TOKEN_SUPPLY = "output_token_supply";
  @SerializedName(SERIALIZED_NAME_OUTPUT_TOKEN_SUPPLY)
  private String outputTokenSupply;

  public static final String SERIALIZED_NAME_OUTPUT_TOKEN_PRICE_USD = "output_token_price_usd";
  @SerializedName(SERIALIZED_NAME_OUTPUT_TOKEN_PRICE_USD)
  private String outputTokenPriceUsd;

  public static final String SERIALIZED_NAME_STAKED_OUTPUT_TOKEN_AMOUNT = "staked_output_token_amount";
  @SerializedName(SERIALIZED_NAME_STAKED_OUTPUT_TOKEN_AMOUNT)
  private String stakedOutputTokenAmount;

  public static final String SERIALIZED_NAME_REWARD_TOKEN_EMISSIONS_AMOUNT = "reward_token_emissions_amount";
  @SerializedName(SERIALIZED_NAME_REWARD_TOKEN_EMISSIONS_AMOUNT)
  private List<String> rewardTokenEmissionsAmount;

  public static final String SERIALIZED_NAME_REWARD_TOKEN_EMISSIONS_USD = "reward_token_emissions_usd";
  @SerializedName(SERIALIZED_NAME_REWARD_TOKEN_EMISSIONS_USD)
  private List<String> rewardTokenEmissionsUsd;

  public static final String SERIALIZED_NAME_REGISTRY_ADDRESS = "registry_address";
  @SerializedName(SERIALIZED_NAME_REGISTRY_ADDRESS)
  private String registryAddress;

  public static final String SERIALIZED_NAME_GAUGE_ADDRESS = "gauge_address";
  @SerializedName(SERIALIZED_NAME_GAUGE_ADDRESS)
  private String gaugeAddress;

  public static final String SERIALIZED_NAME_EVALUATED_ASK = "evaluated_ask";
  @SerializedName(SERIALIZED_NAME_EVALUATED_ASK)
  private Double evaluatedAsk;

  public CURVEFINANCEETHEREUMLiquidityPoolDTO() {
  }

  
  public CURVEFINANCEETHEREUMLiquidityPoolDTO(
     Double evaluatedAsk
  ) {
    this();
    this.evaluatedAsk = evaluatedAsk;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO entryTime(OffsetDateTime entryTime) {
    
    this.entryTime = entryTime;
    return this;
  }

   /**
   * Get entryTime
   * @return entryTime
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getEntryTime() {
    return entryTime;
  }


  public void setEntryTime(OffsetDateTime entryTime) {
    this.entryTime = entryTime;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO recvTime(OffsetDateTime recvTime) {
    
    this.recvTime = recvTime;
    return this;
  }

   /**
   * Get recvTime
   * @return recvTime
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getRecvTime() {
    return recvTime;
  }


  public void setRecvTime(OffsetDateTime recvTime) {
    this.recvTime = recvTime;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO blockNumber(Long blockNumber) {
    
    this.blockNumber = blockNumber;
    return this;
  }

   /**
   * Number of block in which entity was recorded.
   * @return blockNumber
  **/
  @javax.annotation.Nullable
  public Long getBlockNumber() {
    return blockNumber;
  }


  public void setBlockNumber(Long blockNumber) {
    this.blockNumber = blockNumber;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO vid(Long vid) {
    
    this.vid = vid;
    return this;
  }

   /**
   * 
   * @return vid
  **/
  @javax.annotation.Nullable
  public Long getVid() {
    return vid;
  }


  public void setVid(Long vid) {
    this.vid = vid;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO id(String id) {
    
    this.id = id;
    return this;
  }

   /**
   * Smart contract address of the pool
   * @return id
  **/
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO protocol(String protocol) {
    
    this.protocol = protocol;
    return this;
  }

   /**
   * The protocol this pool belongs to
   * @return protocol
  **/
  @javax.annotation.Nullable
  public String getProtocol() {
    return protocol;
  }


  public void setProtocol(String protocol) {
    this.protocol = protocol;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT)
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO symbol(String symbol) {
    
    this.symbol = symbol;
    return this;
  }

   /**
   * Symbol of liquidity pool (e.g. 3CRV)
   * @return symbol
  **/
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }


  public void setSymbol(String symbol) {
    this.symbol = symbol;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO inputTokens(List<String> inputTokens) {
    
    this.inputTokens = inputTokens;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addInputTokensItem(String inputTokensItem) {
    if (this.inputTokens == null) {
      this.inputTokens = new ArrayList<>();
    }
    this.inputTokens.add(inputTokensItem);
    return this;
  }

   /**
   * Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer
   * @return inputTokens
  **/
  @javax.annotation.Nullable
  public List<String> getInputTokens() {
    return inputTokens;
  }


  public void setInputTokens(List<String> inputTokens) {
    this.inputTokens = inputTokens;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO inputTokensOrdered(List<String> inputTokensOrdered) {
    
    this.inputTokensOrdered = inputTokensOrdered;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addInputTokensOrderedItem(String inputTokensOrderedItem) {
    if (this.inputTokensOrdered == null) {
      this.inputTokensOrdered = new ArrayList<>();
    }
    this.inputTokensOrdered.add(inputTokensOrderedItem);
    return this;
  }

   /**
   * inputTokens in native (contract) order
   * @return inputTokensOrdered
  **/
  @javax.annotation.Nullable
  public List<String> getInputTokensOrdered() {
    return inputTokensOrdered;
  }


  public void setInputTokensOrdered(List<String> inputTokensOrdered) {
    this.inputTokensOrdered = inputTokensOrdered;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO outputToken(String outputToken) {
    
    this.outputToken = outputToken;
    return this;
  }

   /**
   * Token that is minted to track ownership of position in protocol
   * @return outputToken
  **/
  @javax.annotation.Nullable
  public String getOutputToken() {
    return outputToken;
  }


  public void setOutputToken(String outputToken) {
    this.outputToken = outputToken;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO rewardTokens(List<String> rewardTokens) {
    
    this.rewardTokens = rewardTokens;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addRewardTokensItem(String rewardTokensItem) {
    if (this.rewardTokens == null) {
      this.rewardTokens = new ArrayList<>();
    }
    this.rewardTokens.add(rewardTokensItem);
    return this;
  }

   /**
   * Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon
   * @return rewardTokens
  **/
  @javax.annotation.Nullable
  public List<String> getRewardTokens() {
    return rewardTokens;
  }


  public void setRewardTokens(List<String> rewardTokens) {
    this.rewardTokens = rewardTokens;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO fees(List<String> fees) {
    
    this.fees = fees;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addFeesItem(String feesItem) {
    if (this.fees == null) {
      this.fees = new ArrayList<>();
    }
    this.fees.add(feesItem);
    return this;
  }

   /**
   * Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee.)
   * @return fees
  **/
  @javax.annotation.Nullable
  public List<String> getFees() {
    return fees;
  }


  public void setFees(List<String> fees) {
    this.fees = fees;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO isSingleSided(Boolean isSingleSided) {
    
    this.isSingleSided = isSingleSided;
    return this;
  }

   /**
   * Whether this pool is single-sided (e.g. Bancor, Platypus&#39;s Alternative Pool). The specifics of the implementation depends on the protocol.
   * @return isSingleSided
  **/
  @javax.annotation.Nullable
  public Boolean getIsSingleSided() {
    return isSingleSided;
  }


  public void setIsSingleSided(Boolean isSingleSided) {
    this.isSingleSided = isSingleSided;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO createdTimestamp(String createdTimestamp) {
    
    this.createdTimestamp = createdTimestamp;
    return this;
  }

   /**
   * Creation timestamp
   * @return createdTimestamp
  **/
  @javax.annotation.Nullable
  public String getCreatedTimestamp() {
    return createdTimestamp;
  }


  public void setCreatedTimestamp(String createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO createdBlockNumber(String createdBlockNumber) {
    
    this.createdBlockNumber = createdBlockNumber;
    return this;
  }

   /**
   * Creation block number
   * @return createdBlockNumber
  **/
  @javax.annotation.Nullable
  public String getCreatedBlockNumber() {
    return createdBlockNumber;
  }


  public void setCreatedBlockNumber(String createdBlockNumber) {
    this.createdBlockNumber = createdBlockNumber;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO totalValueLockedUsd(String totalValueLockedUsd) {
    
    this.totalValueLockedUsd = totalValueLockedUsd;
    return this;
  }

   /**
   * Current TVL (Total Value Locked) of this pool in USD
   * @return totalValueLockedUsd
  **/
  @javax.annotation.Nullable
  public String getTotalValueLockedUsd() {
    return totalValueLockedUsd;
  }


  public void setTotalValueLockedUsd(String totalValueLockedUsd) {
    this.totalValueLockedUsd = totalValueLockedUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO cumulativeSupplySideRevenueUsd(String cumulativeSupplySideRevenueUsd) {
    
    this.cumulativeSupplySideRevenueUsd = cumulativeSupplySideRevenueUsd;
    return this;
  }

   /**
   * All revenue generated by the liquidity pool, accrued to the supply side.
   * @return cumulativeSupplySideRevenueUsd
  **/
  @javax.annotation.Nullable
  public String getCumulativeSupplySideRevenueUsd() {
    return cumulativeSupplySideRevenueUsd;
  }


  public void setCumulativeSupplySideRevenueUsd(String cumulativeSupplySideRevenueUsd) {
    this.cumulativeSupplySideRevenueUsd = cumulativeSupplySideRevenueUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO cumulativeProtocolSideRevenueUsd(String cumulativeProtocolSideRevenueUsd) {
    
    this.cumulativeProtocolSideRevenueUsd = cumulativeProtocolSideRevenueUsd;
    return this;
  }

   /**
   * All revenue generated by the liquidity pool, accrued to the protocol.
   * @return cumulativeProtocolSideRevenueUsd
  **/
  @javax.annotation.Nullable
  public String getCumulativeProtocolSideRevenueUsd() {
    return cumulativeProtocolSideRevenueUsd;
  }


  public void setCumulativeProtocolSideRevenueUsd(String cumulativeProtocolSideRevenueUsd) {
    this.cumulativeProtocolSideRevenueUsd = cumulativeProtocolSideRevenueUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO cumulativeTotalRevenueUsd(String cumulativeTotalRevenueUsd) {
    
    this.cumulativeTotalRevenueUsd = cumulativeTotalRevenueUsd;
    return this;
  }

   /**
   * All revenue generated by the liquidity pool.
   * @return cumulativeTotalRevenueUsd
  **/
  @javax.annotation.Nullable
  public String getCumulativeTotalRevenueUsd() {
    return cumulativeTotalRevenueUsd;
  }


  public void setCumulativeTotalRevenueUsd(String cumulativeTotalRevenueUsd) {
    this.cumulativeTotalRevenueUsd = cumulativeTotalRevenueUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO cumulativeVolumeUsd(String cumulativeVolumeUsd) {
    
    this.cumulativeVolumeUsd = cumulativeVolumeUsd;
    return this;
  }

   /**
   * All historical trade volume occurred in this pool, in USD
   * @return cumulativeVolumeUsd
  **/
  @javax.annotation.Nullable
  public String getCumulativeVolumeUsd() {
    return cumulativeVolumeUsd;
  }


  public void setCumulativeVolumeUsd(String cumulativeVolumeUsd) {
    this.cumulativeVolumeUsd = cumulativeVolumeUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO inputTokenBalances(List<String> inputTokenBalances) {
    
    this.inputTokenBalances = inputTokenBalances;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addInputTokenBalancesItem(String inputTokenBalancesItem) {
    if (this.inputTokenBalances == null) {
      this.inputTokenBalances = new ArrayList<>();
    }
    this.inputTokenBalances.add(inputTokenBalancesItem);
    return this;
  }

   /**
   * Amount of input tokens in the pool. The ordering should be the same as the pool&#39;s &#x60;inputTokens&#x60; field.
   * @return inputTokenBalances
  **/
  @javax.annotation.Nullable
  public List<String> getInputTokenBalances() {
    return inputTokenBalances;
  }


  public void setInputTokenBalances(List<String> inputTokenBalances) {
    this.inputTokenBalances = inputTokenBalances;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO inputTokenWeights(List<String> inputTokenWeights) {
    
    this.inputTokenWeights = inputTokenWeights;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addInputTokenWeightsItem(String inputTokenWeightsItem) {
    if (this.inputTokenWeights == null) {
      this.inputTokenWeights = new ArrayList<>();
    }
    this.inputTokenWeights.add(inputTokenWeightsItem);
    return this;
  }

   /**
   * Weights of input tokens in the liquidity pool in percentage values.
   * @return inputTokenWeights
  **/
  @javax.annotation.Nullable
  public List<String> getInputTokenWeights() {
    return inputTokenWeights;
  }


  public void setInputTokenWeights(List<String> inputTokenWeights) {
    this.inputTokenWeights = inputTokenWeights;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO outputTokenSupply(String outputTokenSupply) {
    
    this.outputTokenSupply = outputTokenSupply;
    return this;
  }

   /**
   * Total supply of output token.
   * @return outputTokenSupply
  **/
  @javax.annotation.Nullable
  public String getOutputTokenSupply() {
    return outputTokenSupply;
  }


  public void setOutputTokenSupply(String outputTokenSupply) {
    this.outputTokenSupply = outputTokenSupply;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO outputTokenPriceUsd(String outputTokenPriceUsd) {
    
    this.outputTokenPriceUsd = outputTokenPriceUsd;
    return this;
  }

   /**
   * Price per share of output token in USD
   * @return outputTokenPriceUsd
  **/
  @javax.annotation.Nullable
  public String getOutputTokenPriceUsd() {
    return outputTokenPriceUsd;
  }


  public void setOutputTokenPriceUsd(String outputTokenPriceUsd) {
    this.outputTokenPriceUsd = outputTokenPriceUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO stakedOutputTokenAmount(String stakedOutputTokenAmount) {
    
    this.stakedOutputTokenAmount = stakedOutputTokenAmount;
    return this;
  }

   /**
   * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
   * @return stakedOutputTokenAmount
  **/
  @javax.annotation.Nullable
  public String getStakedOutputTokenAmount() {
    return stakedOutputTokenAmount;
  }


  public void setStakedOutputTokenAmount(String stakedOutputTokenAmount) {
    this.stakedOutputTokenAmount = stakedOutputTokenAmount;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO rewardTokenEmissionsAmount(List<String> rewardTokenEmissionsAmount) {
    
    this.rewardTokenEmissionsAmount = rewardTokenEmissionsAmount;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addRewardTokenEmissionsAmountItem(String rewardTokenEmissionsAmountItem) {
    if (this.rewardTokenEmissionsAmount == null) {
      this.rewardTokenEmissionsAmount = new ArrayList<>();
    }
    this.rewardTokenEmissionsAmount.add(rewardTokenEmissionsAmountItem);
    return this;
  }

   /**
   * Per-block reward token emission as of the current block normalized to a day, in token&#39;s native amount.
   * @return rewardTokenEmissionsAmount
  **/
  @javax.annotation.Nullable
  public List<String> getRewardTokenEmissionsAmount() {
    return rewardTokenEmissionsAmount;
  }


  public void setRewardTokenEmissionsAmount(List<String> rewardTokenEmissionsAmount) {
    this.rewardTokenEmissionsAmount = rewardTokenEmissionsAmount;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO rewardTokenEmissionsUsd(List<String> rewardTokenEmissionsUsd) {
    
    this.rewardTokenEmissionsUsd = rewardTokenEmissionsUsd;
    return this;
  }

  public CURVEFINANCEETHEREUMLiquidityPoolDTO addRewardTokenEmissionsUsdItem(String rewardTokenEmissionsUsdItem) {
    if (this.rewardTokenEmissionsUsd == null) {
      this.rewardTokenEmissionsUsd = new ArrayList<>();
    }
    this.rewardTokenEmissionsUsd.add(rewardTokenEmissionsUsdItem);
    return this;
  }

   /**
   * Per-block reward token emission as of the current block normalized to a day, in USD value.
   * @return rewardTokenEmissionsUsd
  **/
  @javax.annotation.Nullable
  public List<String> getRewardTokenEmissionsUsd() {
    return rewardTokenEmissionsUsd;
  }


  public void setRewardTokenEmissionsUsd(List<String> rewardTokenEmissionsUsd) {
    this.rewardTokenEmissionsUsd = rewardTokenEmissionsUsd;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO registryAddress(String registryAddress) {
    
    this.registryAddress = registryAddress;
    return this;
  }

   /**
   * Registry that deployed this pool
   * @return registryAddress
  **/
  @javax.annotation.Nullable
  public String getRegistryAddress() {
    return registryAddress;
  }


  public void setRegistryAddress(String registryAddress) {
    this.registryAddress = registryAddress;
  }


  public CURVEFINANCEETHEREUMLiquidityPoolDTO gaugeAddress(String gaugeAddress) {
    
    this.gaugeAddress = gaugeAddress;
    return this;
  }

   /**
   * Liquidity Gauge assocaited with this pool
   * @return gaugeAddress
  **/
  @javax.annotation.Nullable
  public String getGaugeAddress() {
    return gaugeAddress;
  }


  public void setGaugeAddress(String gaugeAddress) {
    this.gaugeAddress = gaugeAddress;
  }


   /**
   * Get evaluatedAsk
   * @return evaluatedAsk
  **/
  @javax.annotation.Nullable
  public Double getEvaluatedAsk() {
    return evaluatedAsk;
  }





  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CURVEFINANCEETHEREUMLiquidityPoolDTO cuRVEFINANCEETHEREUMLiquidityPoolDTO = (CURVEFINANCEETHEREUMLiquidityPoolDTO) o;
    return Objects.equals(this.entryTime, cuRVEFINANCEETHEREUMLiquidityPoolDTO.entryTime) &&
        Objects.equals(this.recvTime, cuRVEFINANCEETHEREUMLiquidityPoolDTO.recvTime) &&
        Objects.equals(this.blockNumber, cuRVEFINANCEETHEREUMLiquidityPoolDTO.blockNumber) &&
        Objects.equals(this.vid, cuRVEFINANCEETHEREUMLiquidityPoolDTO.vid) &&
        Objects.equals(this.id, cuRVEFINANCEETHEREUMLiquidityPoolDTO.id) &&
        Objects.equals(this.protocol, cuRVEFINANCEETHEREUMLiquidityPoolDTO.protocol) &&
        Objects.equals(this.name, cuRVEFINANCEETHEREUMLiquidityPoolDTO.name) &&
        Objects.equals(this.symbol, cuRVEFINANCEETHEREUMLiquidityPoolDTO.symbol) &&
        Objects.equals(this.inputTokens, cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokens) &&
        Objects.equals(this.inputTokensOrdered, cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokensOrdered) &&
        Objects.equals(this.outputToken, cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputToken) &&
        Objects.equals(this.rewardTokens, cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokens) &&
        Objects.equals(this.fees, cuRVEFINANCEETHEREUMLiquidityPoolDTO.fees) &&
        Objects.equals(this.isSingleSided, cuRVEFINANCEETHEREUMLiquidityPoolDTO.isSingleSided) &&
        Objects.equals(this.createdTimestamp, cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdTimestamp) &&
        Objects.equals(this.createdBlockNumber, cuRVEFINANCEETHEREUMLiquidityPoolDTO.createdBlockNumber) &&
        Objects.equals(this.totalValueLockedUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.totalValueLockedUsd) &&
        Objects.equals(this.cumulativeSupplySideRevenueUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeSupplySideRevenueUsd) &&
        Objects.equals(this.cumulativeProtocolSideRevenueUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeProtocolSideRevenueUsd) &&
        Objects.equals(this.cumulativeTotalRevenueUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeTotalRevenueUsd) &&
        Objects.equals(this.cumulativeVolumeUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.cumulativeVolumeUsd) &&
        Objects.equals(this.inputTokenBalances, cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenBalances) &&
        Objects.equals(this.inputTokenWeights, cuRVEFINANCEETHEREUMLiquidityPoolDTO.inputTokenWeights) &&
        Objects.equals(this.outputTokenSupply, cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenSupply) &&
        Objects.equals(this.outputTokenPriceUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.outputTokenPriceUsd) &&
        Objects.equals(this.stakedOutputTokenAmount, cuRVEFINANCEETHEREUMLiquidityPoolDTO.stakedOutputTokenAmount) &&
        Objects.equals(this.rewardTokenEmissionsAmount, cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsAmount) &&
        Objects.equals(this.rewardTokenEmissionsUsd, cuRVEFINANCEETHEREUMLiquidityPoolDTO.rewardTokenEmissionsUsd) &&
        Objects.equals(this.registryAddress, cuRVEFINANCEETHEREUMLiquidityPoolDTO.registryAddress) &&
        Objects.equals(this.gaugeAddress, cuRVEFINANCEETHEREUMLiquidityPoolDTO.gaugeAddress) &&
        Objects.equals(this.evaluatedAsk, cuRVEFINANCEETHEREUMLiquidityPoolDTO.evaluatedAsk);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(entryTime, recvTime, blockNumber, vid, id, protocol, name, symbol, inputTokens, inputTokensOrdered, outputToken, rewardTokens, fees, isSingleSided, createdTimestamp, createdBlockNumber, totalValueLockedUsd, cumulativeSupplySideRevenueUsd, cumulativeProtocolSideRevenueUsd, cumulativeTotalRevenueUsd, cumulativeVolumeUsd, inputTokenBalances, inputTokenWeights, outputTokenSupply, outputTokenPriceUsd, stakedOutputTokenAmount, rewardTokenEmissionsAmount, rewardTokenEmissionsUsd, registryAddress, gaugeAddress, evaluatedAsk);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CURVEFINANCEETHEREUMLiquidityPoolDTO {\n");
    sb.append("    entryTime: ").append(toIndentedString(entryTime)).append("\n");
    sb.append("    recvTime: ").append(toIndentedString(recvTime)).append("\n");
    sb.append("    blockNumber: ").append(toIndentedString(blockNumber)).append("\n");
    sb.append("    vid: ").append(toIndentedString(vid)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    inputTokens: ").append(toIndentedString(inputTokens)).append("\n");
    sb.append("    inputTokensOrdered: ").append(toIndentedString(inputTokensOrdered)).append("\n");
    sb.append("    outputToken: ").append(toIndentedString(outputToken)).append("\n");
    sb.append("    rewardTokens: ").append(toIndentedString(rewardTokens)).append("\n");
    sb.append("    fees: ").append(toIndentedString(fees)).append("\n");
    sb.append("    isSingleSided: ").append(toIndentedString(isSingleSided)).append("\n");
    sb.append("    createdTimestamp: ").append(toIndentedString(createdTimestamp)).append("\n");
    sb.append("    createdBlockNumber: ").append(toIndentedString(createdBlockNumber)).append("\n");
    sb.append("    totalValueLockedUsd: ").append(toIndentedString(totalValueLockedUsd)).append("\n");
    sb.append("    cumulativeSupplySideRevenueUsd: ").append(toIndentedString(cumulativeSupplySideRevenueUsd)).append("\n");
    sb.append("    cumulativeProtocolSideRevenueUsd: ").append(toIndentedString(cumulativeProtocolSideRevenueUsd)).append("\n");
    sb.append("    cumulativeTotalRevenueUsd: ").append(toIndentedString(cumulativeTotalRevenueUsd)).append("\n");
    sb.append("    cumulativeVolumeUsd: ").append(toIndentedString(cumulativeVolumeUsd)).append("\n");
    sb.append("    inputTokenBalances: ").append(toIndentedString(inputTokenBalances)).append("\n");
    sb.append("    inputTokenWeights: ").append(toIndentedString(inputTokenWeights)).append("\n");
    sb.append("    outputTokenSupply: ").append(toIndentedString(outputTokenSupply)).append("\n");
    sb.append("    outputTokenPriceUsd: ").append(toIndentedString(outputTokenPriceUsd)).append("\n");
    sb.append("    stakedOutputTokenAmount: ").append(toIndentedString(stakedOutputTokenAmount)).append("\n");
    sb.append("    rewardTokenEmissionsAmount: ").append(toIndentedString(rewardTokenEmissionsAmount)).append("\n");
    sb.append("    rewardTokenEmissionsUsd: ").append(toIndentedString(rewardTokenEmissionsUsd)).append("\n");
    sb.append("    registryAddress: ").append(toIndentedString(registryAddress)).append("\n");
    sb.append("    gaugeAddress: ").append(toIndentedString(gaugeAddress)).append("\n");
    sb.append("    evaluatedAsk: ").append(toIndentedString(evaluatedAsk)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("entry_time");
    openapiFields.add("recv_time");
    openapiFields.add("block_number");
    openapiFields.add("vid");
    openapiFields.add("id");
    openapiFields.add("protocol");
    openapiFields.add("name");
    openapiFields.add("symbol");
    openapiFields.add("input_tokens");
    openapiFields.add("input_tokens_ordered");
    openapiFields.add("output_token");
    openapiFields.add("reward_tokens");
    openapiFields.add("fees");
    openapiFields.add("is_single_sided");
    openapiFields.add("created_timestamp");
    openapiFields.add("created_block_number");
    openapiFields.add("total_value_locked_usd");
    openapiFields.add("cumulative_supply_side_revenue_usd");
    openapiFields.add("cumulative_protocol_side_revenue_usd");
    openapiFields.add("cumulative_total_revenue_usd");
    openapiFields.add("cumulative_volume_usd");
    openapiFields.add("input_token_balances");
    openapiFields.add("input_token_weights");
    openapiFields.add("output_token_supply");
    openapiFields.add("output_token_price_usd");
    openapiFields.add("staked_output_token_amount");
    openapiFields.add("reward_token_emissions_amount");
    openapiFields.add("reward_token_emissions_usd");
    openapiFields.add("registry_address");
    openapiFields.add("gauge_address");
    openapiFields.add("evaluated_ask");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to CURVEFINANCEETHEREUMLiquidityPoolDTO
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!CURVEFINANCEETHEREUMLiquidityPoolDTO.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CURVEFINANCEETHEREUMLiquidityPoolDTO is not found in the empty JSON string", CURVEFINANCEETHEREUMLiquidityPoolDTO.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!CURVEFINANCEETHEREUMLiquidityPoolDTO.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CURVEFINANCEETHEREUMLiquidityPoolDTO` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("input_tokens") != null && !jsonObj.get("input_tokens").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `input_tokens` to be an array in the JSON string but got `%s`", jsonObj.get("input_tokens").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("input_tokens_ordered") != null && !jsonObj.get("input_tokens_ordered").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `input_tokens_ordered` to be an array in the JSON string but got `%s`", jsonObj.get("input_tokens_ordered").toString()));
      }
      if ((jsonObj.get("output_token") != null && !jsonObj.get("output_token").isJsonNull()) && !jsonObj.get("output_token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `output_token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("output_token").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("reward_tokens") != null && !jsonObj.get("reward_tokens").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `reward_tokens` to be an array in the JSON string but got `%s`", jsonObj.get("reward_tokens").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("fees") != null && !jsonObj.get("fees").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `fees` to be an array in the JSON string but got `%s`", jsonObj.get("fees").toString()));
      }
      if ((jsonObj.get("created_timestamp") != null && !jsonObj.get("created_timestamp").isJsonNull()) && !jsonObj.get("created_timestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `created_timestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("created_timestamp").toString()));
      }
      if ((jsonObj.get("created_block_number") != null && !jsonObj.get("created_block_number").isJsonNull()) && !jsonObj.get("created_block_number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `created_block_number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("created_block_number").toString()));
      }
      if ((jsonObj.get("total_value_locked_usd") != null && !jsonObj.get("total_value_locked_usd").isJsonNull()) && !jsonObj.get("total_value_locked_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `total_value_locked_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("total_value_locked_usd").toString()));
      }
      if ((jsonObj.get("cumulative_supply_side_revenue_usd") != null && !jsonObj.get("cumulative_supply_side_revenue_usd").isJsonNull()) && !jsonObj.get("cumulative_supply_side_revenue_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cumulative_supply_side_revenue_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cumulative_supply_side_revenue_usd").toString()));
      }
      if ((jsonObj.get("cumulative_protocol_side_revenue_usd") != null && !jsonObj.get("cumulative_protocol_side_revenue_usd").isJsonNull()) && !jsonObj.get("cumulative_protocol_side_revenue_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cumulative_protocol_side_revenue_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cumulative_protocol_side_revenue_usd").toString()));
      }
      if ((jsonObj.get("cumulative_total_revenue_usd") != null && !jsonObj.get("cumulative_total_revenue_usd").isJsonNull()) && !jsonObj.get("cumulative_total_revenue_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cumulative_total_revenue_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cumulative_total_revenue_usd").toString()));
      }
      if ((jsonObj.get("cumulative_volume_usd") != null && !jsonObj.get("cumulative_volume_usd").isJsonNull()) && !jsonObj.get("cumulative_volume_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cumulative_volume_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cumulative_volume_usd").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("input_token_balances") != null && !jsonObj.get("input_token_balances").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `input_token_balances` to be an array in the JSON string but got `%s`", jsonObj.get("input_token_balances").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("input_token_weights") != null && !jsonObj.get("input_token_weights").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `input_token_weights` to be an array in the JSON string but got `%s`", jsonObj.get("input_token_weights").toString()));
      }
      if ((jsonObj.get("output_token_supply") != null && !jsonObj.get("output_token_supply").isJsonNull()) && !jsonObj.get("output_token_supply").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `output_token_supply` to be a primitive type in the JSON string but got `%s`", jsonObj.get("output_token_supply").toString()));
      }
      if ((jsonObj.get("output_token_price_usd") != null && !jsonObj.get("output_token_price_usd").isJsonNull()) && !jsonObj.get("output_token_price_usd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `output_token_price_usd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("output_token_price_usd").toString()));
      }
      if ((jsonObj.get("staked_output_token_amount") != null && !jsonObj.get("staked_output_token_amount").isJsonNull()) && !jsonObj.get("staked_output_token_amount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `staked_output_token_amount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("staked_output_token_amount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("reward_token_emissions_amount") != null && !jsonObj.get("reward_token_emissions_amount").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `reward_token_emissions_amount` to be an array in the JSON string but got `%s`", jsonObj.get("reward_token_emissions_amount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("reward_token_emissions_usd") != null && !jsonObj.get("reward_token_emissions_usd").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `reward_token_emissions_usd` to be an array in the JSON string but got `%s`", jsonObj.get("reward_token_emissions_usd").toString()));
      }
      if ((jsonObj.get("registry_address") != null && !jsonObj.get("registry_address").isJsonNull()) && !jsonObj.get("registry_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `registry_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("registry_address").toString()));
      }
      if ((jsonObj.get("gauge_address") != null && !jsonObj.get("gauge_address").isJsonNull()) && !jsonObj.get("gauge_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gauge_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gauge_address").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CURVEFINANCEETHEREUMLiquidityPoolDTO.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CURVEFINANCEETHEREUMLiquidityPoolDTO' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CURVEFINANCEETHEREUMLiquidityPoolDTO> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CURVEFINANCEETHEREUMLiquidityPoolDTO.class));

       return (TypeAdapter<T>) new TypeAdapter<CURVEFINANCEETHEREUMLiquidityPoolDTO>() {
           @Override
           public void write(JsonWriter out, CURVEFINANCEETHEREUMLiquidityPoolDTO value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CURVEFINANCEETHEREUMLiquidityPoolDTO read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CURVEFINANCEETHEREUMLiquidityPoolDTO given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CURVEFINANCEETHEREUMLiquidityPoolDTO
  * @throws IOException if the JSON string is invalid with respect to CURVEFINANCEETHEREUMLiquidityPoolDTO
  */
  public static CURVEFINANCEETHEREUMLiquidityPoolDTO fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CURVEFINANCEETHEREUMLiquidityPoolDTO.class);
  }

 /**
  * Convert an instance of CURVEFINANCEETHEREUMLiquidityPoolDTO to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

