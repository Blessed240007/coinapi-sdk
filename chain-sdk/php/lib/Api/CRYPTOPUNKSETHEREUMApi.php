<?php
/**
 * CRYPTOPUNKSETHEREUMApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * On Chain Dapps - REST API
 *
 * This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * CRYPTOPUNKSETHEREUMApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CRYPTOPUNKSETHEREUMApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cRYPTOPUNKSETHEREUMBidsCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMCollectionsCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMDataSourcesCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMItemsCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMMarketPlacesCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMTradesCurrent' => [
            'application/json',
        ],
        'cRYPTOPUNKSETHEREUMUsersCurrent' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMBidsCurrent
     *
     * Bids (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]
     */
    public function cRYPTOPUNKSETHEREUMBidsCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMBidsCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMBidsCurrentWithHttpInfo
     *
     * Bids (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMBidsCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMBidsCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMBidsCurrentAsync
     *
     * Bids (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMBidsCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMBidsCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMBidsCurrentAsyncWithHttpInfo
     *
     * Bids (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMBidsCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSBidDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMBidsCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMBidsCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMBidsCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMBidsCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/bids/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent
     *
     * CollectionDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]
     */
    public function cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentWithHttpInfo
     *
     * CollectionDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentAsync
     *
     * CollectionDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentAsyncWithHttpInfo
     *
     * CollectionDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDailySnapshotDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionDailySnapshotsCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/collectionDailySnapshots/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionsCurrent
     *
     * Collections (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]
     */
    public function cRYPTOPUNKSETHEREUMCollectionsCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMCollectionsCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionsCurrentWithHttpInfo
     *
     * Collections (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMCollectionsCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMCollectionsCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionsCurrentAsync
     *
     * Collections (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMCollectionsCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMCollectionsCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMCollectionsCurrentAsyncWithHttpInfo
     *
     * Collections (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMCollectionsCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSCollectionDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMCollectionsCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMCollectionsCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMCollectionsCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMCollectionsCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/collections/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMDataSourcesCurrent
     *
     * DataSources (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]
     */
    public function cRYPTOPUNKSETHEREUMDataSourcesCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMDataSourcesCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMDataSourcesCurrentWithHttpInfo
     *
     * DataSources (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMDataSourcesCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMDataSourcesCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMDataSourcesCurrentAsync
     *
     * DataSources (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMDataSourcesCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMDataSourcesCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMDataSourcesCurrentAsyncWithHttpInfo
     *
     * DataSources (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMDataSourcesCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSDataSourcesDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMDataSourcesCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMDataSourcesCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMDataSourcesCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMDataSourcesCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/dataSources/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMItemsCurrent
     *
     * Items (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]
     */
    public function cRYPTOPUNKSETHEREUMItemsCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMItemsCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMItemsCurrentWithHttpInfo
     *
     * Items (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMItemsCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMItemsCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMItemsCurrentAsync
     *
     * Items (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMItemsCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMItemsCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMItemsCurrentAsyncWithHttpInfo
     *
     * Items (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMItemsCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSItemDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMItemsCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMItemsCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMItemsCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMItemsCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/items/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketPlacesCurrent
     *
     * MarketPlaces (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]
     */
    public function cRYPTOPUNKSETHEREUMMarketPlacesCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMMarketPlacesCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketPlacesCurrentWithHttpInfo
     *
     * MarketPlaces (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMMarketPlacesCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMMarketPlacesCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketPlacesCurrentAsync
     *
     * MarketPlaces (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMMarketPlacesCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMMarketPlacesCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketPlacesCurrentAsyncWithHttpInfo
     *
     * MarketPlaces (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMMarketPlacesCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSMarketPlaceDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMMarketPlacesCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMMarketPlacesCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMMarketPlacesCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketPlacesCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/marketPlaces/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent
     *
     * MarketplaceDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]
     */
    public function cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentWithHttpInfo
     *
     * MarketplaceDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentAsync
     *
     * MarketplaceDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentAsyncWithHttpInfo
     *
     * MarketplaceDailySnapshots (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSMarketplaceDailySnapshotDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMMarketplaceDailySnapshotsCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/marketplaceDailySnapshots/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMTradesCurrent
     *
     * Trades (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]
     */
    public function cRYPTOPUNKSETHEREUMTradesCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMTradesCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMTradesCurrentWithHttpInfo
     *
     * Trades (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMTradesCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMTradesCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMTradesCurrentAsync
     *
     * Trades (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMTradesCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMTradesCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMTradesCurrentAsyncWithHttpInfo
     *
     * Trades (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMTradesCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSTradeDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMTradesCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMTradesCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMTradesCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMTradesCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/trades/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMUsersCurrent
     *
     * Users (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]
     */
    public function cRYPTOPUNKSETHEREUMUsersCurrent(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'][0])
    {
        list($response) = $this->cRYPTOPUNKSETHEREUMUsersCurrentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMUsersCurrentWithHttpInfo
     *
     * Users (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cRYPTOPUNKSETHEREUMUsersCurrentWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'][0])
    {
        $request = $this->cRYPTOPUNKSETHEREUMUsersCurrentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMUsersCurrentAsync
     *
     * Users (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMUsersCurrentAsync(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'][0])
    {
        return $this->cRYPTOPUNKSETHEREUMUsersCurrentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cRYPTOPUNKSETHEREUMUsersCurrentAsyncWithHttpInfo
     *
     * Users (current)
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cRYPTOPUNKSETHEREUMUsersCurrentAsyncWithHttpInfo(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CRYPTOPUNKSUserDTO[]';
        $request = $this->cRYPTOPUNKSETHEREUMUsersCurrentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cRYPTOPUNKSETHEREUMUsersCurrent'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cRYPTOPUNKSETHEREUMUsersCurrentRequest(string $contentType = self::contentTypes['cRYPTOPUNKSETHEREUMUsersCurrent'][0])
    {


        $resourcePath = '/v1/dapps/cryptopunks-ethereum/users/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
